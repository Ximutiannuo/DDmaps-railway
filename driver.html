<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- iOS小型机型优化：防止自动缩放，确保正确显示 -->
    <!-- 注意：禁用页面缩放，但地图区域仍可通过代码支持双指缩放 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <!-- 额外的触摸优化 -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>司机路线规划系统</title>
    <!-- 模块化 JavaScript 文件 -->
    <script src="js/utils.js"></script>
    <script src="js/api.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- 样式文件 -->
    <link rel="stylesheet" href="css/driver.css">
</head>
<body>
    <!-- ==================== 移动端优化布局 ==================== -->
    <!-- 注意：原CSS代码（约1160行）已提取到 css/driver.css 文件中 -->
    <!--:root {
            --primary: #667eea;
            --primary-dark: #5a67d8;
            --primary-light: #7c8ff4;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc;
            --border: #e2e8f0;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 25px -5px rgba(0, 0, 0, 0.15);
            --radius: 12px;
            --radius-lg: 20px;
            /* 底部面板高度 - 调整为更合理的值 */
            --panel-collapsed: 180px;
            --panel-half: 55vh;  /* 增加半屏高度，确保能看到更多内容 */
            --panel-full: calc(100vh - 50px);  /* 展开时顶部留50px给状态栏 */
            --top-bar-height: 50px;  /* 顶部状态栏高度 */
            --safe-area-bottom: env(safe-area-inset-bottom, 0px);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            font-family: 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100%;
            overflow: hidden;
            background: #f0f4f8;
            color: var(--text-primary);
            -webkit-font-smoothing: antialiased;
        }

        /* ========== 主容器 - 全屏布局 ========== */
        .app-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            max-width: 100%;
            margin: 0 auto;
        }

        /* ========== 顶部状态栏 ========== */
        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: linear-gradient(180deg, rgba(0,0,0,0.4) 0%, transparent 100%);
            pointer-events: none;
        }
        
        .top-bar > * {
            pointer-events: auto;
        }
        
        .app-title {
            color: white;
            font-size: 16px;
            font-weight: 600;
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .top-bar-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .lang-switcher {
            display: flex;
            gap: 6px;
        }
        
        /* 标签切换按钮 - 顶部栏样式 */
        .label-toggle-btn {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255,255,255,0.25);
            border: 1px solid rgba(255,255,255,0.4);
            color: white;
            padding: 5px 10px;
            border-radius: 16px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        
        .label-toggle-btn:hover {
            background: rgba(255,255,255,0.35);
        }
        
        .label-toggle-btn:active {
            transform: scale(0.95);
        }
        
        .label-icon {
            font-size: 12px;
        }
        
        .label-text {
            font-size: 11px;
        }
        
        /* 标签按钮不同状态的颜色 */
        .label-toggle-btn[data-mode="全部"] {
            background: rgba(102, 126, 234, 0.5);
            border-color: rgba(102, 126, 234, 0.7);
        }
        
        .label-toggle-btn[data-mode="仅节点"] {
            background: rgba(243, 156, 18, 0.5);
            border-color: rgba(243, 156, 18, 0.7);
        }

        .lang-btn {
            background: rgba(255,255,255,0.25);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .lang-btn:hover {
            background: rgba(255,255,255,0.35);
        }

        .lang-btn.active {
            background: white;
            color: var(--primary);
        }

        /* ========== 地图区域 - 固定在上部 ========== */
        .map-area {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1;
        }

        /* ========== 底部面板 - 可拖拽抽屉 ========== */
        .bottom-panel {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 100;
            background: var(--bg-primary);
            border-radius: var(--radius-lg) var(--radius-lg) 0 0;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.15);
            transition: height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            padding-bottom: var(--safe-area-bottom);
            /* 默认半屏状态 */
            height: var(--panel-half);
        }
        
        .bottom-panel.collapsed {
            height: var(--panel-collapsed);
        }
        
        .bottom-panel.half {
            height: var(--panel-half);
        }
        
        .bottom-panel.expanded {
            height: var(--panel-full);
        }

        /* 拖拽手柄 */
        .panel-handle {
            padding: 12px;
            cursor: grab;
            touch-action: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }
        
        .panel-handle:active {
            cursor: grabbing;
        }
        
        .handle-bar {
            width: 40px;
            height: 4px;
            background: #d1d5db;
            border-radius: 2px;
        }
        
        .panel-status {
            font-size: 13px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* 面板内容区 */
        .panel-content {
            flex: 1 1 0;  /* 关键：使用flex-basis: 0，允许收缩 */
            overflow-y: auto;
            overflow-x: hidden;
            padding: 0 16px 20px;
            -webkit-overflow-scrolling: touch;
            /* 确保内容可以完全滚动 - min-height: 0 是flex布局滚动的关键 */
            min-height: 0;
            /* 底部额外padding确保按钮可见 */
            padding-bottom: calc(40px + var(--safe-area-bottom));
        }
        
        .panel-content::-webkit-scrollbar {
            width: 4px;
        }
        
        .panel-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }
        
        /* 确保最后一个section有足够的底部空间 */
        .panel-content > .section:last-child,
        .panel-content > .map-legend:last-child {
            margin-bottom: 50px;
        }

        /* ========== 快捷操作栏 ========== */
        .quick-actions {
            display: flex;
            gap: 10px;
            padding: 0 0 16px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }
        
        .quick-actions::-webkit-scrollbar {
            display: none;
        }
        
        .quick-action-btn {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.2s;
            min-width: 70px;
        }
        
        .quick-action-btn:hover, .quick-action-btn:active {
            background: #e8f0fe;
            border-color: var(--primary);
        }
        
        .quick-action-btn.active {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            border-color: var(--primary);
            color: white;
        }
        
        .quick-action-icon {
            font-size: 20px;
        }
        
        .quick-action-label {
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
        }

        /* ========== 卡片样式 ========== */
        .section {
            margin-bottom: 16px;
            padding: 16px;
            background: var(--bg-secondary);
            border-radius: var(--radius);
            border: 1px solid var(--border);
        }

        .section-title {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .section-title::before {
            content: '';
            width: 4px;
            height: 16px;
            background: linear-gradient(180deg, var(--primary) 0%, var(--primary-dark) 100%);
            border-radius: 2px;
        }

        /* 可折叠section样式 */
        .section.collapsible .section-title {
            cursor: pointer;
            user-select: none;
        }
        
        .section.collapsible .section-title::after {
            content: '▼';
            font-size: 10px;
            margin-left: auto;
            transition: transform 0.3s;
            color: var(--text-secondary);
        }
        
        .section.collapsible.collapsed .section-title::after {
            transform: rotate(-90deg);
        }
        
        .section-content {
            transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
            overflow: hidden;
        }
        
        .section.collapsed .section-content {
            max-height: 0 !important;
            opacity: 0;
            padding-top: 0;
            padding-bottom: 0;
        }
        
        .section-summary {
            display: none;
            padding: 10px;
            background: var(--bg-primary);
            border-radius: 8px;
            font-size: 13px;
            color: var(--text-secondary);
            margin-top: 8px;
        }
        
        .section.collapsed .section-summary {
            display: block;
        }

        .form-group {
            margin-bottom: 14px;
        }

        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 13px;
        }

        input, select {
            width: 100%;
            padding: 12px 14px;
            border: 1.5px solid var(--border);
            border-radius: 10px;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.2s;
            background: var(--bg-primary);
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        button {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .input-hint {
            display: block;
            margin-top: 6px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* 运行模式选择样式 */
        input[name="vehicle-mode"] {
            width: auto;
            margin-right: 8px;
            cursor: pointer;
        }

        input[name="vehicle-mode"]:checked + span {
            color: var(--primary);
            font-weight: 600;
        }

        label:has(input[name="vehicle-mode"]:checked) {
            background: #e8f0fe !important;
            border-color: var(--primary) !important;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.15);
        }

        label:has(input[name="vehicle-mode"]) {
            transition: all 0.2s ease;
        }

        label:has(input[name="vehicle-mode"]):hover {
            background: #f0f4ff !important;
            border-color: var(--primary) !important;
        }

        .planner-warning {
            margin-top: 12px;
            padding: 10px;
            border-radius: 8px;
            background: #fef3c7;
            border-left: 4px solid var(--warning);
            color: #92400e;
            font-size: 13px;
        }

        .planner-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 11px;
            font-weight: 600;
            color: #fff;
            background: linear-gradient(135deg, #8b5cf6, #a78bfa);
            margin-left: 8px;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .result-card {
            background: var(--bg-primary);
            border: 2px solid var(--primary);
            border-radius: var(--radius);
            padding: 15px;
            margin-top: 15px;
        }
        
        /* ========== 隐藏原有header ========== */
        .header {
            display: none;
        }
        
        .container {
            display: none;
        }
        
        .content {
            padding: 0;
        }

        .result-item {
            margin-bottom: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .result-label {
            font-weight: bold;
            color: #667eea;
            margin-right: 10px;
        }

        .route-path {
            padding: 10px;
            background: #e8f4f8;
            border-left: 4px solid #667eea;
            margin-top: 10px;
            border-radius: 5px;
        }

        .route-path-item {
            padding: 5px 0;
            display: flex;
            align-items: center;
        }

        .route-arrow {
            margin: 0 10px;
            color: #667eea;
            font-weight: bold;
        }

        .alert {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .alert-warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            color: #856404;
        }

        .alert-danger {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            color: #721c24;
        }

        .alert-info {
            background: #d1ecf1;
            border-left: 4px solid #17a2b8;
            color: #0c5460;
        }

        .alert-success {
            background: #d4edda;
            border-left: 4px solid #28a745;
            color: #155724;
        }

        .road-status {
            display: flex;
            align-items: center;
            margin-top: 10px;
            padding: 8px;
            background: white;
            border-radius: 5px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-normal {
            background: #28a745;
        }

        .status-congested {
            background: #dc3545;
        }

        .status-closed {
            background: #6c757d;
        }

        .status-construction {
            background: #ffc107;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #667eea;
        }

        .history-item {
            padding: 10px;
            background: white;
            border-radius: 5px;
            margin-bottom: 10px;
            border-left: 4px solid #667eea;
        }

        .history-time {
            font-size: 12px;
            color: #999;
            margin-top: 5px;
        }

        /* ========== 地图相关样式 ========== */
        .map-section {
            display: none; /* 隐藏原地图区块，使用新布局 */
        }

        .map-container {
            width: 100%;
            height: 100%;
            background: #f0f4f8;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            touch-action: none; /* 禁用浏览器默认触控行为，由JS完全控制 */
            cursor: grab;
            user-select: none;
            /* 网格背景 */
            background-image: 
                linear-gradient(rgba(0, 0, 0, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.03) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        .map-container:active {
            cursor: grabbing;
        }

        .map-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            touch-action: none; /* 禁用浏览器默认触控行为，由JS完全控制 */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        #map {
            position: relative;
            transform-origin: 0 0;
            transition: none;
            will-change: transform;
        }
        
        /* 地图控制按钮 - 浮动在地图上 */
        .map-floating-controls {
            position: absolute;
            top: 60px;
            right: 12px;
            z-index: 50;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .map-float-btn {
            width: 44px;
            height: 44px;
            background: white;
            border: none;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            color: var(--text-primary);
            transition: all 0.2s;
            padding: 0;
        }
        
        .map-float-btn:hover {
            background: var(--bg-secondary);
            transform: scale(1.05);
        }
        
        .map-float-btn:active {
            transform: scale(0.95);
        }
        
        .zoom-display {
            font-size: 11px;
            color: var(--text-secondary);
            text-align: center;
            padding: 4px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .map-node {
            position: absolute;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            border: 1px solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            /* 允许拖动穿透：节点不阻止地图拖动 */
            pointer-events: auto;
            /* 节点允许触摸事件，但通过 JavaScript 处理拖动逻辑 */
            touch-action: pan-x pan-y pinch-zoom;
        }

        .map-node:hover {
            transform: translate(-50%, -50%) scale(1.2);
            z-index: 25;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .map-node.entrance {
            background: rgba(46, 204, 113, 0.9); /* #2ecc71 */
            width: 22px;
            height: 22px;
        }

        .map-node.work-area {
            background: rgba(231, 76, 60, 0.9); /* #e74c3c */
        }

        .map-node.crossroad {
            background: rgba(52, 152, 219, 0.9); /* #3498db */
        }

        .map-node.start {
            background: rgba(155, 89, 182, 0.9); /* #9b59b6 */
        }
        
        /* 节点内部编号样式 */
        .node-number {
            color: #ffffff;
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            line-height: 1;
            user-select: none;
            pointer-events: none;
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
            /* 缩放字体以适应小节点，如果数字较多 */
            transform: scale(0.9);
        }
        
        /* 入口节点使用稍大字体 */
        .map-node.entrance .node-number {
            font-size: 11px;
            transform: scale(1);
        }

        .driver-location-marker {
            position: absolute;
            z-index: 100;
        }

        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 0.5;
            }
            100% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }

        .map-edge {
            position: absolute;
            height: 2px;
            background: #7f8c8d;
            transform-origin: 0 0;
            z-index: 10;
            user-select: none;
        }

        .map-edge.congested {
            background: #e74c3c;
            height: 4px;
            box-shadow: 0 0 5px rgba(231,76,60,0.5);
        }

        .map-edge.construction {
            background: #f39c12;
            height: 5px;
            box-shadow: 0 0 8px rgba(243,156,18,0.8);
            border-top: 2px dashed #e67e22;
            border-bottom: 2px dashed #e67e22;
        }

        .map-edge.closed {
            background: #95a5a6;
            opacity: 0.5;
            height: 1px;
        }

        .map-edge.one-way {
            background: #e67e22;
            height: 3px;
        }

        .map-edge-label {
            position: absolute;
            font-size: 9px;
            background: rgba(255, 255, 255, 0.95);
            padding: 1px 3px;
            border-radius: 2px;
            white-space: nowrap;
            pointer-events: none;
            z-index: 18;
            border: 1px solid #667eea;
            color: #667eea;
            font-weight: bold;
            user-select: none;
        }

        .map-arrow {
            position: absolute;
            /* 使用SVG创建更明显的箭头 */
            width: 32px;
            height: 32px;
            transform: translate(-50%, -50%);
            transform-origin: center center;
            z-index: 19;
            pointer-events: none;
        }
        
        /* 使用SVG箭头，更明显且清晰 - 带箭杆的箭头 */
        .map-arrow::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            width: 32px;
            height: 32px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'%3E%3Cdefs%3E%3Cfilter id='shadow'%3E%3CfeDropShadow dx='0' dy='2' stdDeviation='3' flood-opacity='0.5'/%3E%3C/filter%3E%3C/defs%3E%3Cpath d='M 16 2 L 28 16 L 22 16 L 22 24 L 10 24 L 10 16 L 4 16 Z' fill='%23e67e22' stroke='%23ffffff' stroke-width='1.5' filter='url(%23shadow)'/%3E%3C/svg%3E");
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            transform: translate(-50%, -50%);
        }
        
        /* 备选方案：如果SVG不支持，使用CSS三角形 */
        @supports not (background-image: url('data:image/svg+xml')) {
            .map-arrow::before {
                content: '';
                position: absolute;
                left: 50%;
                top: 50%;
                width: 0;
                height: 0;
                /* 使用更大的箭头尺寸，更加明显 */
                border-left: 12px solid transparent;
                border-right: 12px solid transparent;
                border-top: 20px solid #e67e22;
                transform: translate(-50%, -50%);
                /* 添加阴影效果，让箭头更明显 */
                filter: drop-shadow(0 2px 6px rgba(230,126,34,0.8)) drop-shadow(0 0 2px rgba(0,0,0,0.5));
                /* 确保箭头有良好的对比度 */
                box-shadow: 0 0 4px rgba(0,0,0,0.3);
            }
        }

        .map-route {
            position: absolute;
            height: 5px;
            background: #27ae60;
            transform-origin: 0 0;
            z-index: 15;
            opacity: 0.9;
            box-shadow: 0 0 10px rgba(39,174,96,0.8);
            border-radius: 2px;
        }

        .map-label {
            position: absolute;
            font-size: 11px;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 4px;
            border-radius: 2px;
            white-space: nowrap;
            pointer-events: none;
            z-index: 25;
            border: 1px solid #ddd;
            user-select: none;
        }

        /* 标签显示控制 */
        /* 仅显示节点编号（隐藏道路名称） */
        .map-labels-nodes-only .map-edge-label {
            display: none !important;
        }

        .map-legend {
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 9px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin: 15px 0;
            overflow-x: auto;
            overflow-y: hidden;
            transition: all 0.3s ease;
        }

        .map-legend-header {
            display: none; /* 水平布局时隐藏标题 */
        }

        .map-legend-content {
            display: flex;
            flex-direction: row;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        .map-legend-section {
            display: flex;
            flex-direction: row;
            gap: 8px;
            align-items: center;
            padding-right: 10px;
            border-right: 1px solid #ddd;
        }

        .map-legend-section:last-child {
            border-right: none;
            padding-right: 0;
        }

        .map-legend-item {
            display: flex;
            align-items: center;
            margin: 0;
            font-size: 9px;
            white-space: nowrap;
            gap: 4px;
        }

        .map-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .map-controls {
            display: flex;
            flex-direction: row;
            gap: 8px;
            margin-top: 10px;
            justify-content: flex-start;
            align-items: center;
            flex-wrap: wrap;
        }

        .map-control-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ddd;
            padding: 6px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            white-space: nowrap;
            color: #333;
            text-align: center;
            min-height: 32px;
            line-height: 1.4;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
        }
        
        .map-control-btn:hover {
            background: white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            transform: translateY(-1px);
        }

        .zoom-controls {
            display: flex;
            flex-direction: row;
            gap: 5px;
            background: rgba(255, 255, 255, 0.95);
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #ddd;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .zoom-btn-group {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .zoom-btn {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid #667eea;
            padding: 6px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            flex: 1;
            color: #667eea;
            min-width: 30px;
            line-height: 1;
        }

        .zoom-btn:hover {
            background: rgba(102, 126, 234, 0.2);
        }

        .zoom-level {
            text-align: center;
            font-size: 11px;
            color: #666;
            padding: 0 8px;
            font-weight: bold;
            min-width: 45px;
            border-left: 1px solid #ddd;
            border-right: 1px solid #ddd;
        }

        /* ========== 响应式设计 ========== */
        @media (max-width: 768px) {
            :root {
                --panel-collapsed: 160px;
                --panel-half: 55vh;
            }
            
            .map-legend {
                font-size: 8px;
                padding: 8px 10px;
                margin: 10px 0;
            }
            .map-legend-item {
                font-size: 8px;
                gap: 3px;
            }
            .map-legend-section {
                gap: 6px;
                padding-right: 8px;
            }
            .map-legend-color {
                width: 10px;
                height: 10px;
            }
            
            .section {
                padding: 14px;
                margin-bottom: 12px;
            }
            
            .section-title {
                font-size: 14px;
            }
            
            .quick-action-btn {
                padding: 10px 12px;
                min-width: 60px;
            }
            
            .quick-action-icon {
                font-size: 18px;
            }
            
            .quick-action-label {
                font-size: 10px;
            }
        }
        
        @media (max-width: 400px) {
            :root {
                --panel-collapsed: 140px;
            }
            
            .top-bar {
                padding: 10px 12px;
            }
            
            .app-title {
                font-size: 14px;
            }
            
            .lang-btn {
                padding: 5px 8px;
                font-size: 11px;
            }
            
            .label-toggle-btn {
                padding: 4px 8px;
            }
            
            .label-icon {
                font-size: 10px;
            }
            
            .label-text {
                font-size: 10px;
            }
        }
        
        /* iOS安全区域适配 */
        @supports (padding-bottom: env(safe-area-inset-bottom)) {
            .bottom-panel {
                padding-bottom: calc(env(safe-area-inset-bottom) + 10px);
            }
        } -->
</head>
<body>
    <!-- ========== 新布局：类似高德地图APP ========== -->
    <div class="app-container">
        <!-- 顶部状态栏 -->
        <div class="top-bar">
            <span class="app-title" data-i18n="app_title">🚛 司机路线规划</span>
            <div class="top-bar-right">
                <button class="label-toggle-btn" id="toggle-labels" title="当前: 全部显示" data-mode="全部">
                    <span class="label-icon">🏷️</span>
                    <span class="label-text">全部</span>
                </button>
                <div class="lang-switcher">
                    <button class="lang-btn active" data-lang="zh">中文</button>
                    <button class="lang-btn" data-lang="en">EN</button>
                    <button class="lang-btn" data-lang="ru">РУ</button>
                </div>
            </div>
        </div>
        
        <!-- 地图区域 - 全屏背景 -->
        <div class="map-area">
            <div class="map-container">
                <div class="map-wrapper" id="map-wrapper">
                    <div id="map">
                        <div class="loading" data-i18n="loading_map">正在加载地图...</div>
                    </div>
                </div>
            </div>
            
            <!-- 地图浮动控制按钮 -->
            <div class="map-floating-controls">
                <button class="map-float-btn" id="zoom-in" title="放大">+</button>
                <button class="map-float-btn" id="zoom-out" title="缩小">−</button>
                <div class="zoom-display" id="zoom-level">50%</div>
                <button class="map-float-btn" id="reset-map-view" title="重置视图">⟲</button>
                <button class="map-float-btn" id="toggle-map-fullscreen" title="全屏">⛶</button>
            </div>
        </div>
        
        <!-- 底部面板 - 可拖拽抽屉 -->
        <div class="bottom-panel half" id="bottom-panel">
            <!-- 拖拽手柄 -->
            <div class="panel-handle" id="panel-handle">
                <div class="handle-bar"></div>
                <div class="panel-status">
                    <span class="status-dot"></span>
                    <span id="connection-status" data-i18n="connected">已连接</span>
                </div>
            </div>
            
            <!-- 面板内容 -->
            <div class="panel-content" id="panel-content">
                <!-- 快捷操作 -->
                <div class="quick-actions" id="quick-actions">
                    <button class="quick-action-btn active" data-section="driver-section">
                        <span class="quick-action-icon">👤</span>
                        <span class="quick-action-label" data-i18n="driver_info_short">司机</span>
                    </button>
                    <button class="quick-action-btn" data-section="mode-section">
                        <span class="quick-action-icon">🎮</span>
                        <span class="quick-action-label" data-i18n="mode_short">模式</span>
                    </button>
                    <button class="quick-action-btn" data-section="route-section">
                        <span class="quick-action-icon">🗺️</span>
                        <span class="quick-action-label" data-i18n="route_short">路线</span>
                    </button>
                    <button class="quick-action-btn" data-section="result-section">
                        <span class="quick-action-icon">📍</span>
                        <span class="quick-action-label" data-i18n="result_short">结果</span>
                    </button>
                    <button class="quick-action-btn" data-section="history-section">
                        <span class="quick-action-icon">📋</span>
                        <span class="quick-action-label" data-i18n="history_short">记录</span>
                    </button>
                </div>
                
                <!-- 司机信息 -->
                <div class="section collapsible" id="driver-section">
                    <div class="section-title" data-i18n="driver_info">司机信息</div>
                    <div class="section-summary" id="driver-section-summary"></div>
                    <div class="section-content" id="driver-section-content">
                        <div class="form-group">
                            <label data-i18n="driver_id">司机ID *</label>
                            <input type="text" id="driver-id" placeholder="请输入司机ID" data-i18n-placeholder="driver_id_placeholder" required>
                        </div>
                        <div class="form-group">
                            <label data-i18n="driver_name">姓名</label>
                            <input type="text" id="driver-name" placeholder="请输入姓名" data-i18n-placeholder="driver_name_placeholder">
                        </div>
                        <div class="form-group">
                            <label data-i18n="license_plate">车牌号</label>
                            <input type="text" id="driver-license-plate" placeholder="请输入车牌号" data-i18n-placeholder="license_plate_placeholder">
                        </div>
                        <div class="form-group">
                            <label data-i18n="driver_phone">联系电话</label>
                            <input type="tel" id="driver-phone" placeholder="请输入联系电话" data-i18n-placeholder="driver_phone_placeholder">
                        </div>
                        <button id="register-driver" data-i18n="register">📝 注册/更新信息</button>
                        <div id="driver-info-display" style="margin-top: 15px; padding: 12px; background: var(--bg-primary); border-radius: 10px; border: 1px solid var(--border); display: none;">
                            <div style="font-weight: 600; margin-bottom: 8px; color: var(--primary);" data-i18n="current_driver_info">当前司机信息</div>
                            <div id="driver-info-content" style="font-size: 13px; color: var(--text-secondary);"></div>
                        </div>
                    </div>
                </div>

                <!-- 运行模式选择 -->
                <div class="section" id="mode-section">
                    <div class="section-title" data-i18n="vehicle_mode_title">运行模式</div>
                    <div class="form-group" id="vehicle-mode-group">
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <label style="display: flex; align-items: center; cursor: pointer; flex: 1; padding: 14px; background: var(--bg-primary); border: 2px solid var(--border); border-radius: 10px; transition: all 0.2s;">
                                <input type="radio" name="vehicle-mode" value="auto" checked style="margin-right: 10px;" class="active-mode-radio">
                                <span style="font-weight: 500;" data-i18n="vehicle_mode_auto">🚗 自动模式</span>
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; flex: 1; padding: 14px; background: var(--bg-primary); border: 2px solid var(--border); border-radius: 10px; transition: all 0.2s;">
                                <input type="radio" name="vehicle-mode" value="gps" style="margin-right: 10px;" class="active-mode-radio">
                                <span style="font-weight: 500;" data-i18n="vehicle_mode_gps">📍 GPS模式</span>
                            </label>
                        </div>
                        <small class="input-hint" style="margin-top: 10px; display: block; line-height: 1.6;" id="vehicle-mode-hint">
                            <strong data-i18n="vehicle_mode_auto">自动模式</strong>：<span data-i18n="vehicle_mode_auto_desc">车辆按照设定速度自动沿路线行驶</span><br>
                            <strong data-i18n="vehicle_mode_gps">GPS模式</strong>：<span data-i18n="vehicle_mode_gps_desc">车辆位置根据您的GPS实时更新</span>
                        </small>
                    </div>
                </div>

                <!-- 路线规划 -->
                <div class="section" id="route-section">
                    <div class="section-title" data-i18n="route_planning">路线规划</div>
                    <div class="form-group">
                        <label data-i18n="vehicle_type">车辆类型</label>
                        <select id="vehicle-type"></select>
                    </div>
                    <div class="form-group">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div>
                                <label data-i18n="vehicle_weight">载重 (吨)</label>
                                <input type="number" id="vehicle-weight" min="1" max="50" value="20">
                            </div>
                            <div>
                                <label data-i18n="vehicle_width">宽度 (米)</label>
                                <input type="number" id="vehicle-width" min="1" max="6" step="0.1" value="3">
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label data-i18n="vehicle_speed_custom">自定义速度 (km/h)</label>
                        <input type="number" id="vehicle-speed" min="1" max="120" step="1" placeholder="例如 35">
                    </div>
                    <div class="form-group">
                        <label data-i18n="planner_mode">路线算法</label>
                        <select id="planner-mode">
                            <option value="classic" selected data-i18n="planner_default_option">系统推荐（默认）</option>
                            <option value="dqn" data-i18n="planner_dqn_option">深度学习（DQN）</option>
                        </select>
                    </div>
                    <div class="form-group dqn-advanced" id="dqn-epsilon-group" style="display:none;">
                        <label data-i18n="dqn_epsilon">探索率 ε (0-1)</label>
                        <input type="number" id="dqn-epsilon" min="0" max="1" step="0.05" value="0.1">
                    </div>
                    <div class="form-group">
                        <label data-i18n="start_node">起点</label>
                        <select id="start-node"></select>
                    </div>
                    <div class="form-group">
                        <label data-i18n="target_node">终点</label>
                        <select id="target-node"></select>
                        <small class="input-hint" style="color: var(--primary); font-weight: 500;" data-i18n="click_node_hint">
                            💡 提示：可在地图上直接点击节点选择终点
                        </small>
                    </div>
                    <button id="calculate-route" data-i18n="calculate_route">🗺️ 计算最优路线</button>
                </div>

                <!-- 路线结果 -->
                <div id="route-result" class="section" style="display: none;">
                    <div class="section-title" id="route-result-title" data-i18n="route_result">路线结果</div>
                    <div id="result-content"></div>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button id="submit-vehicle" style="flex: 1; background: var(--success);" data-i18n="submit_vehicle">✅ 提交车辆</button>
                        <button id="mark-arrived" style="flex: 1; background: var(--warning); display: none;" data-i18n="mark_arrived">🏁 已到达</button>
                    </div>
                    <button id="cancel-navigation" style="width: 100%; margin-top: 10px; background: var(--danger); opacity: 0.85;" data-i18n="cancel_navigation">🚫 中断导航</button>
                </div>
                
                <!-- 历史记录占位 -->
                <div class="section" id="history-section">
                    <div class="section-title" data-i18n="history">历史记录</div>
                    <div id="history-list" style="max-height: 200px; overflow-y: auto;">
                        <div class="loading">加载中...</div>
                    </div>
                </div>
                
                <!-- 图例 -->
                <div class="map-legend" id="driver-map-legend" style="margin-top: 16px;">
                    <div class="map-legend-content">
                        <div class="map-legend-section">
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#2ecc71;"></div>
                                <span data-i18n="legend_entrance">进场口</span>
                            </div>
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#3498db;"></div>
                                <span data-i18n="legend_crossroad">交叉口</span>
                            </div>
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#e74c3c;"></div>
                                <span data-i18n="legend_work_area">作业区</span>
                            </div>
                        </div>
                        <div class="map-legend-section">
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#e67e22; width:16px; height:3px; border-radius:0;"></div>
                                <span data-i18n="legend_one_way">单向</span>
                            </div>
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#e74c3c; width:16px; height:4px; border-radius:0;"></div>
                                <span data-i18n="legend_congested">拥堵</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 保留原有container用于兼容性，但隐藏 -->
    <div class="container" style="display: none;">
        <div class="header">
            <div class="lang-switcher">
                <button class="lang-btn active" data-lang="zh">中文</button>
                <button class="lang-btn" data-lang="en">English</button>
                <button class="lang-btn" data-lang="ru">Русский</button>
            </div>
            <h1 data-i18n="title">司机路线规划系统</h1>
            <p data-i18n="subtitle">实时道路状态 · 智能路径推荐</p>
        </div>

        <div class="content">
            <!-- 司机信息 -->
            <div class="section">
                <div class="section-title" data-i18n="driver_info">司机信息</div>
                <div class="form-group">
                    <label data-i18n="driver_id">司机ID *</label>
                    <input type="text" id="driver-id" placeholder="请输入司机ID" data-i18n-placeholder="driver_id_placeholder" required>
                </div>
                <div class="form-group">
                    <label data-i18n="driver_name">姓名</label>
                    <input type="text" id="driver-name" placeholder="请输入姓名" data-i18n-placeholder="driver_name_placeholder">
                </div>
                <div class="form-group">
                    <label data-i18n="license_plate">车牌号</label>
                    <input type="text" id="driver-license-plate" placeholder="请输入车牌号" data-i18n-placeholder="license_plate_placeholder">
                </div>
                <div class="form-group">
                    <label data-i18n="driver_phone">联系电话</label>
                    <input type="tel" id="driver-phone" placeholder="请输入联系电话" data-i18n-placeholder="driver_phone_placeholder">
                </div>
                <button id="register-driver" data-i18n="register">注册/更新信息</button>
                <div id="driver-info-display" style="margin-top: 15px; padding: 10px; background: #f0f0f0; border-radius: 5px; display: none;">
                    <div style="font-weight: bold; margin-bottom: 5px;" data-i18n="current_driver_info">当前司机信息</div>
                    <div id="driver-info-content"></div>
                </div>
            </div>

            <!-- 运行模式选择 -->
            <div class="section">
                <div class="section-title" style="font-weight: bold; margin-bottom: 15px;" data-i18n="vehicle_mode_title">运行模式</div>
                <div class="form-group">
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <label style="display: flex; align-items: center; cursor: pointer; flex: 1; padding: 12px; background: #f8f9fa; border: 2px solid #e0e0e0; border-radius: 8px; transition: all 0.3s;">
                            <input type="radio" name="vehicle-mode" value="auto" checked style="margin-right: 8px;">
                            <span style="font-weight: 500;" data-i18n="vehicle_mode_auto">🚗 自动模式</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer; flex: 1; padding: 12px; background: #f8f9fa; border: 2px solid #e0e0e0; border-radius: 8px; transition: all 0.3s;">
                            <input type="radio" name="vehicle-mode" value="gps" style="margin-right: 8px;">
                            <span style="font-weight: 500;" data-i18n="vehicle_mode_gps">📍 GPS模式</span>
                        </label>
                    </div>
                    <small class="input-hint" style="margin-top: 10px; display: block;" id="vehicle-mode-hint">
                        <strong data-i18n="vehicle_mode_auto">自动模式</strong><span data-i18n="vehicle_mode_auto_desc">车辆按照设定速度自动沿路线行驶</span><br>
                        <strong data-i18n="vehicle_mode_gps">GPS模式</strong><span data-i18n="vehicle_mode_gps_desc">车辆位置根据您的GPS实时更新（需要开启定位）</span>
                    </small>
                </div>
            </div>

            <!-- 路线规划 -->
            <div class="section">
                <div class="section-title" data-i18n="route_planning">路线规划</div>
                <div class="form-group">
                    <label data-i18n="vehicle_type">车辆类型</label>
                    <select id="vehicle-type"></select>
                </div>
                <div class="form-group">
                    <label data-i18n="vehicle_weight">载重 (吨)</label>
                    <input type="number" id="vehicle-weight" min="1" max="50" value="20">
                </div>
                <div class="form-group">
                    <label data-i18n="vehicle_width">宽度 (米)</label>
                    <input type="number" id="vehicle-width" min="1" max="6" step="0.1" value="3">
                </div>
                <div class="form-group">
                    <label data-i18n="vehicle_speed_custom">自定义速度 (km/h)</label>
                    <input type="number" id="vehicle-speed" min="1" max="120" step="1" placeholder="例如 35">
                </div>
                <div class="form-group">
                    <label data-i18n="planner_mode">路线算法</label>
                    <select id="planner-mode">
                        <option value="classic" selected data-i18n="planner_default_option">系统推荐（默认）</option>
                        <option value="dqn" data-i18n="planner_dqn_option">深度学习（DQN）</option>
                    </select>
                    <small class="input-hint" data-i18n="planner_note">DQN 需后台已训练模型，实验性功能</small>
                </div>
                <div class="form-group dqn-advanced" id="dqn-epsilon-group" style="display:none;">
                    <label data-i18n="dqn_epsilon">探索率 ε (0-1)</label>
                    <input type="number" id="dqn-epsilon" min="0" max="1" step="0.05" value="0.1">
                    <small class="input-hint" data-i18n="dqn_hint">越大越随机，默认 0.1</small>
                </div>
                <div class="form-group">
                    <label data-i18n="start_node">起点</label>
                    <select id="start-node"></select>
                </div>
                <div class="form-group">
                    <label data-i18n="target_node">终点</label>
                    <select id="target-node"></select>
                    <small class="input-hint" style="display: block; margin-top: 5px; color: #667eea; font-weight: 500;">
                        💡 提示：您可以在地图上直接点击节点来选择终点
                    </small>
                </div>
                <button id="calculate-route" data-i18n="calculate_route">计算最优路线</button>
            </div>

            <!-- 路线结果 -->
            <div id="route-result" style="display: none;">
                <div class="section">
                    <div class="section-title" id="route-result-title" data-i18n="route_result">路线结果</div>
                    <div id="result-content"></div>
                    <button id="submit-vehicle" style="background: #27ae60; margin-top: 15px;" data-i18n="submit_vehicle">提交为实际车辆</button>
                    <button id="mark-arrived" style="background: #f1c40f; margin-top: 10px; display: none;" data-i18n="mark_arrived">已到达</button>
                </div>
            </div>

            <!-- 地图显示 -->
            <div class="map-section">
                <div class="section-title" data-i18n="map_view">地图视图</div>
                <div class="map-controls">
                    <div class="zoom-controls">
                        <div class="zoom-btn-group">
                            <button class="zoom-btn" id="zoom-in" title="放大" aria-label="放大">+</button>
                            <button class="zoom-btn" id="zoom-out" title="缩小" aria-label="缩小">−</button>
                        </div>
                        <div class="zoom-level" id="zoom-level">50%</div>
                        <button class="zoom-btn" id="zoom-reset" data-i18n="zoom_reset">重置</button>
                    </div>
                    <button class="map-control-btn" id="reset-map-view" data-i18n="reset_view">重置视图</button>
                    <button class="map-control-btn" id="toggle-map-fullscreen" data-i18n="fullscreen">全屏</button>
                </div>
                <div class="map-container">
                    <div class="map-wrapper" id="map-wrapper">
                        <div id="map">
                        <div class="loading" data-i18n="loading_map">正在加载地图...</div>
                        </div>
                    </div>
                </div>
                <!-- 图例：放在地图和道路状态之间 -->
                <div class="map-legend" id="driver-map-legend">
                    <div class="map-legend-content">
                        <div class="map-legend-section">
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#2ecc71;"></div>
                                <span data-i18n="legend_entrance">进场口</span>
                            </div>
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#3498db;"></div>
                                <span data-i18n="legend_crossroad">交叉口</span>
                            </div>
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#e74c3c;"></div>
                                <span data-i18n="legend_work_area">作业区</span>
                            </div>
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#9b59b6;"></div>
                                <span data-i18n="legend_start">场外起点</span>
                            </div>
                        </div>
                        <div class="map-legend-section">
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#f39c12;"></div>
                                <span data-i18n="legend_truck">渣土车</span>
                            </div>
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#8e44ad;"></div>
                                <span data-i18n="legend_material">材料车</span>
                            </div>
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#16a085;"></div>
                                <span data-i18n="legend_construction">工程车</span>
                            </div>
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#e74c3c;"></div>
                                <span data-i18n="legend_special">特种车</span>
                            </div>
                        </div>
                        <div class="map-legend-section">
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#e67e22; width:16px; height:3px; border-radius:0;"></div>
                                <span data-i18n="legend_one_way">单向</span>
                            </div>
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#e74c3c; width:16px; height:4px; border-radius:0;"></div>
                                <span data-i18n="legend_congested">拥堵</span>
                            </div>
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#f39c12; width:16px; height:5px; border-radius:0;"></div>
                                <span data-i18n="legend_construction_road">施工</span>
                            </div>
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#95a5a6; width:16px; height:2px; border-radius:0;"></div>
                                <span data-i18n="legend_closed">封闭</span>
                            </div>
                        </div>
                        <div class="map-legend-section">
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#f39c12; border: 2px solid #e67e22;"></div>
                                <span data-i18n="legend_light_congestion">轻微拥堵</span>
                            </div>
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#e67e22; border: 2px solid #d35400;"></div>
                                <span data-i18n="legend_medium_congestion">中度拥堵</span>
                            </div>
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#e74c3c; border: 2px solid #c0392b;"></div>
                                <span data-i18n="legend_severe_congestion">严重拥堵</span>
                            </div>
                        </div>
                        <div class="map-legend-section">
                            <div class="map-legend-item">
                                <div class="map-legend-color" style="background:#27ae60; width:16px; height:5px; border-radius:2px;"></div>
                                <span data-i18n="legend_route">我的路线</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 道路状态信息 -->
            <div id="road-status" style="display: none;">
                <div class="section">
                    <div class="section-title" data-i18n="road_status">道路状态</div>
                    <div id="status-content"></div>
                </div>
            </div>

            <!-- 历史记录 -->
            <div class="section">
                <div class="section-title" data-i18n="history">历史记录</div>
                <div id="history-content">
                    <div class="loading" data-i18n="no_history">暂无历史记录</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========== 全局错误处理 ==========
        // 捕获并忽略浏览器扩展相关的错误（这些错误不影响应用功能）
        window.addEventListener('unhandledrejection', function(event) {
            const error = event.reason;
            const errorMessage = error?.message || String(error);
            
            // 忽略浏览器扩展相关的错误
            if (errorMessage.includes('message channel closed') || 
                errorMessage.includes('listener indicated an asynchronous response') ||
                errorMessage.includes('Extension context invalidated')) {
                event.preventDefault(); // 阻止错误在控制台显示
                return;
            }
            
            // 其他错误正常处理
            console.error('未处理的Promise拒绝:', error);
        });
        
        // 捕获全局错误（可选，用于调试）
        window.addEventListener('error', function(event) {
            const errorMessage = event.message || '';
            
            // 忽略浏览器扩展相关的错误
            if (errorMessage.includes('message channel closed') || 
                errorMessage.includes('listener indicated an asynchronous response') ||
                errorMessage.includes('Extension context invalidated')) {
                event.preventDefault();
                return;
            }
        });
        
        // 多语言支持
        const i18n = {
            zh: {
                title: '司机路线规划系统',
                subtitle: '实时道路状态 · 智能路径推荐',
                driver_info: '司机信息',
                driver_id: '司机ID',
                driver_id_placeholder: '请输入司机ID',
                driver_name: '姓名',
                driver_name_placeholder: '请输入姓名',
                license_plate: '车牌号',
                license_plate_placeholder: '请输入车牌号',
                driver_phone: '联系电话',
                driver_phone_placeholder: '请输入联系电话',
                current_driver_info: '当前司机信息',
                register: '注册/更新信息',
                route_planning: '路线规划',
                vehicle_type: '车辆类型',
                vehicle_weight: '载重 (吨)',
                vehicle_width: '宽度 (米)',
                vehicle_speed_custom: '自定义速度 (km/h)',
                vehicle_speed_hint: '若留空则使用车辆类型默认速度',
                start_node: '起点',
                target_node: '终点',
                calculate_route: '计算最优路线',
                planner_mode: '路线算法',
                planner_default_option: '系统推荐（默认）',
                planner_dqn_option: '深度学习（DQN）',
                planner_note: 'DQN 需后台已训练模型，结果仅供参考',
                dqn_epsilon: '探索率 ε (0-1)',
                dqn_hint: '越大越随机，默认 0.1',
                dqn_route_unavailable: 'DQN 路线暂不可用，将回退系统默认路线',
                route_result: '路线结果',
                dqn_route_warning: '⚠️ 当前展示为 DQN 深度学习路线，默认仅供参考。',
                road_status: '道路状态',
                history: '历史记录',
                no_history: '暂无历史记录',
                estimated_time: '预计时间',
                efficiency_score: '效率评分',
                route_path: '路线路径',
                congested_roads: '拥堵道路',
                closed_roads: '封闭道路',
                construction_zones: '施工区域',
                normal_roads: '正常道路',
                minutes: '分钟',
                loading: '加载中...',
                success: '成功',
                error: '错误',
                please_select: '请选择',
                please_input: '请输入',
                map_view: '地图视图',
                loading_map: '正在加载地图...',
                legend_title: '图例',
                legend_entrance: '进场口',
                legend_crossroad: '交叉口',
                legend_work_area: '作业区',
                legend_start: '场外起点',
                legend_truck: '渣土车',
                legend_material: '材料车',
                legend_construction: '工程车',
                legend_special: '特种车',
                legend_one_way: '单向道路',
                legend_congested: '拥堵道路',
                legend_construction_road: '占道施工',
                legend_closed: '封闭道路',
                legend_light_congestion: '轻微拥堵节点',
                legend_medium_congestion: '中度拥堵节点',
                legend_severe_congestion: '严重拥堵节点',
                legend_route: '我的路线',
                one_way_roads: '单向道路',
                reset_view: '重置视图',
                fullscreen: '全屏',
                zoom_in: '放大',
                zoom_out: '缩小',
                zoom_reset: '重置',
                submit_vehicle: '提交为实际车辆',
                submit_success: '车辆已提交',
                submit_confirm: '确定要将此路线提交为实际车辆吗？车辆将加入调度系统。',
                mark_arrived: '确认到达',
                cancel_navigation: '中断导航',
                cancel_navigation_confirm: '确定要中断当前导航吗？您可以重新选择终点规划新路线。',
                navigation_cancelled: '导航已中断，可重新规划路线',
                relocating_gps: '正在重新获取GPS位置...',
                location_accuracy: '精度',
                meters: '米',
                my_location: '我的位置',
                gps_location: 'GPS位置',
                nearest_node: '最近节点',
                distance: '距离',
                nearby_nodes: '附近节点',
                tracking_started: '已开始实时位置跟踪',
                tracking_stopped: '已停止位置跟踪',
                vehicle_mode_title: '运行模式',
                vehicle_mode_auto: '自动模式',
                vehicle_mode_gps: 'GPS模式',
                vehicle_mode_auto_desc: '车辆按照设定速度自动沿路线行驶',
                vehicle_mode_gps_desc: '车辆位置根据您的GPS实时更新（需要开启定位）',
                driver_info_name: '姓名',
                driver_info_license_plate: '车牌号',
                driver_info_phone: '联系电话',
                driver_info_vehicle_type: '车辆类型',
                driver_info_registered_at: '注册时间',
                // 新布局相关
                app_title: '🚛 司机路线规划',
                connected: '已连接',
                disconnected: '未连接',
                driver_info_short: '司机',
                mode_short: '模式',
                route_short: '路线',
                result_short: '结果',
                history_short: '记录',
                vehicle_type_truck: '渣土车',
                vehicle_type_material: '材料车',
                vehicle_type_construction: '工程车',
                vehicle_type_special: '特种车',
                get_location_btn: '📍 定位',
                get_location_btn_loading: '定位中...',
                get_location_btn_stop: '📍 停止定位',
                location_hint: '点击定位按钮，系统将根据您的GPS位置推荐最近的节点',
                // 标签切换按钮
                toggle_labels_all_short: '全部',
                toggle_labels_nodes_only_short: '仅节点',
                // 提示文字
                click_node_hint: '💡 提示：可在地图上直接点击节点选择终点'
            },
            en: {
                title: 'Driver Route Planning System',
                subtitle: 'Real-time Road Status · Smart Route Recommendation',
                driver_info: 'Driver Information',
                driver_id: 'Driver ID',
                driver_id_placeholder: 'Please enter Driver ID',
                driver_name: 'Name (Optional)',
                driver_name_placeholder: 'Please enter name',
                license_plate: 'License Plate',
                license_plate_placeholder: 'Please enter license plate',
                driver_phone: 'Contact Phone',
                driver_phone_placeholder: 'Please enter contact phone',
                current_driver_info: 'Current Driver Information',
                register: 'Register/Update',
                route_planning: 'Route Planning',
                vehicle_type: 'Vehicle Type',
                vehicle_weight: 'Weight (tons)',
                vehicle_width: 'Width (meters)',
                vehicle_speed_custom: 'Custom Speed (km/h)',
                vehicle_speed_hint: 'If empty, default speed of vehicle type is used',
                start_node: 'Start Point',
                target_node: 'Destination',
                calculate_route: 'Calculate Optimal Route',
                planner_mode: 'Route Algorithm',
                planner_default_option: 'System Recommended (default)',
                planner_dqn_option: 'Deep Learning (DQN)',
                planner_note: 'DQN requires a trained model on the server and is experimental',
                dqn_epsilon: 'Exploration rate ε (0-1)',
                dqn_hint: 'Higher = more random (default 0.1)',
                dqn_route_unavailable: 'DQN route unavailable, falling back to default planner',
                route_result: 'Route Result',
                dqn_route_warning: '⚠️ This is a DQN deep-learning route preview for reference.',
                road_status: 'Road Status',
                history: 'History',
                no_history: 'No history',
                estimated_time: 'Estimated Time',
                efficiency_score: 'Efficiency Score',
                route_path: 'Route Path',
                congested_roads: 'Congested Roads',
                closed_roads: 'Closed Roads',
                construction_zones: 'Construction Zones',
                normal_roads: 'Normal Roads',
                minutes: 'minutes',
                loading: 'Loading...',
                success: 'Success',
                error: 'Error',
                please_select: 'Please select',
                please_input: 'Please enter',
                map_view: 'Map View',
                loading_map: 'Loading map...',
                legend_title: 'Legend',
                legend_entrance: 'Entrance',
                legend_crossroad: 'Crossroad',
                legend_work_area: 'Work Area',
                legend_start: 'External Start',
                legend_truck: 'Dump Truck',
                legend_material: 'Material Truck',
                legend_construction: 'Construction Vehicle',
                legend_special: 'Special Vehicle',
                legend_one_way: 'One-way Road',
                legend_congested: 'Congested Road',
                legend_construction_road: 'Road Construction',
                legend_closed: 'Closed Road',
                legend_light_congestion: 'Light Congestion Node',
                legend_medium_congestion: 'Medium Congestion Node',
                legend_severe_congestion: 'Severe Congestion Node',
                legend_route: 'My Route',
                one_way_roads: 'One-way Roads',
                reset_view: 'Reset View',
                fullscreen: 'Fullscreen',
                zoom_in: 'Zoom In',
                zoom_out: 'Zoom Out',
                zoom_reset: 'Reset',
                submit_vehicle: 'Submit as Vehicle',
                submit_success: 'Vehicle submitted',
                submit_confirm: 'Are you sure you want to submit this route as an actual vehicle? The vehicle will be added to the dispatch system.',
                mark_arrived: 'Mark as Arrived',
                cancel_navigation: 'Cancel Navigation',
                cancel_navigation_confirm: 'Are you sure you want to cancel the current navigation? You can re-select a destination to plan a new route.',
                navigation_cancelled: 'Navigation cancelled. You can plan a new route.',
                relocating_gps: 'Relocating GPS position...',
                get_location: 'Get Location',
                location_hint: 'Click the location button to get your GPS position and find nearest nodes',
                location_error: 'Failed to get location',
                location_permission_denied: 'Location permission denied',
                location_unavailable: 'Location unavailable',
                select_node: 'Select Node',
                nearest_nodes: 'Nearest Nodes',
                confirm_start: 'Confirm as Start Point',
                location_accuracy: 'Accuracy',
                meters: 'meters',
                get_location_btn: '📍 Get Location',
                get_location_btn_loading: 'Locating...',
                get_location_btn_stop: '📍 Stop Location',
                toggle_labels_all: 'Labels: Show All',
                toggle_labels_edges_only: 'Labels: Edges Only',
                toggle_labels_nodes_only: 'Labels: Nodes Only',
                toggle_labels_hidden: 'Labels: Hidden',
                toggle_labels_all_short: 'All',
                toggle_labels_nodes_only_short: 'Nodes',
                click_node_hint: '💡 Tip: Click on a node on the map to select it as destination',
                my_location: 'My Location',
                gps_location: 'GPS Location',
                nearest_node: 'Nearest Node',
                distance: 'Distance',
                nearby_nodes: 'Nearby Nodes',
                tracking_started: 'Real-time location tracking started',
                tracking_stopped: 'Location tracking stopped',
                vehicle_mode_title: 'Operation Mode',
                vehicle_mode_auto: 'Auto Mode',
                vehicle_mode_gps: 'GPS Mode',
                vehicle_mode_auto_desc: 'Vehicle automatically travels along the route at set speed',
                vehicle_mode_gps_desc: 'Vehicle position updates in real-time based on your GPS (location tracking required)',
                driver_info_name: 'Name',
                driver_info_license_plate: 'License Plate',
                driver_info_phone: 'Contact Phone',
                driver_info_vehicle_type: 'Vehicle Type',
                driver_info_registered_at: 'Registered At',
                // New layout
                app_title: '🚛 Route Planning',
                connected: 'Connected',
                disconnected: 'Disconnected',
                driver_info_short: 'Driver',
                mode_short: 'Mode',
                route_short: 'Route',
                result_short: 'Result',
                history_short: 'History',
                vehicle_type_truck: 'Dump Truck',
                vehicle_type_material: 'Material Truck',
                vehicle_type_construction: 'Construction Vehicle',
                vehicle_type_special: 'Special Vehicle'
            },
            ru: {
                title: 'Система планирования маршрута водителя',
                subtitle: 'Статус дорог в реальном времени · Умная рекомендация маршрута',
                driver_info: 'Информация о водителе',
                driver_id: 'ID водителя',
                driver_id_placeholder: 'Введите ID водителя',
                driver_name: 'Имя (необязательно)',
                driver_name_placeholder: 'Введите имя',
                license_plate: 'Номерной знак',
                license_plate_placeholder: 'Введите номерной знак',
                driver_phone: 'Контактный телефон',
                driver_phone_placeholder: 'Введите контактный телефон',
                current_driver_info: 'Текущая информация о водителе',
                register: 'Зарегистрировать/Обновить',
                route_planning: 'Планирование маршрута',
                vehicle_type: 'Тип транспортного средства',
                vehicle_weight: 'Вес (тонны)',
                vehicle_width: 'Ширина (метры)',
                vehicle_speed_custom: 'Пользовательская скорость (км/ч)',
                vehicle_speed_hint: 'Если оставить пустым, используется скорость типа ТС',
                start_node: 'Точка отправления',
                target_node: 'Пункт назначения',
                calculate_route: 'Рассчитать оптимальный маршрут',
                planner_mode: 'Алгоритм маршрута',
                planner_default_option: 'Системная рекомендация (по умолчанию)',
                planner_dqn_option: 'Глубокое обучение (DQN)',
                planner_note: 'DQN требует обученной модели на сервере, функция экспериментальная',
                dqn_epsilon: 'Параметр исследования ε (0-1)',
                dqn_hint: 'Чем больше, тем случайнее (по умолчанию 0.1)',
                dqn_route_unavailable: 'Маршрут DQN недоступен, используется стандартный алгоритм',
                route_result: 'Результат маршрута',
                dqn_route_warning: '⚠️ Это тестовый маршрут DQN, используется только для справки.',
                road_status: 'Статус дорог',
                history: 'История',
                no_history: 'Нет истории',
                estimated_time: 'Расчетное время',
                efficiency_score: 'Оценка эффективности',
                route_path: 'Путь маршрута',
                congested_roads: 'Перегруженные дороги',
                closed_roads: 'Закрытые дороги',
                construction_zones: 'Зоны строительства',
                normal_roads: 'Нормальные дороги',
                one_way_roads: 'Односторонние дороги',
                minutes: 'минут',
                loading: 'Загрузка...',
                success: 'Успех',
                error: 'Ошибка',
                please_select: 'Пожалуйста, выберите',
                please_input: 'Пожалуйста, введите',
                map_view: 'Вид карты',
                loading_map: 'Загрузка карты...',
                legend_title: 'Легенда',
                legend_entrance: 'Вход',
                legend_crossroad: 'Перекресток',
                legend_work_area: 'Рабочая зона',
                legend_start: 'Внешняя точка отправления',
                legend_truck: 'Самосвал',
                legend_material: 'Материальный грузовик',
                legend_construction: 'Строительная техника',
                legend_special: 'Специальная техника',
                legend_one_way: 'Односторонняя дорога',
                legend_congested: 'Перегруженная дорога',
                legend_construction_road: 'Дорожные работы',
                legend_closed: 'Закрытая дорога',
                legend_light_congestion: 'Легкая перегрузка узла',
                legend_medium_congestion: 'Средняя перегрузка узла',
                legend_severe_congestion: 'Сильная перегрузка узла',
                legend_route: 'Мой маршрут',
                reset_view: 'Сбросить вид',
                fullscreen: 'Полный экран',
                zoom_in: 'Увеличить',
                zoom_out: 'Уменьшить',
                zoom_reset: 'Сбросить',
                submit_vehicle: 'Отправить как транспортное средство',
                submit_success: 'Транспортное средство отправлено',
                submit_confirm: 'Вы уверены, что хотите отправить этот маршрут как фактическое транспортное средство? Транспортное средство будет добавлено в систему диспетчеризации.',
                mark_arrived: 'Подтвердить прибытие',
                cancel_navigation: 'Прервать навигацию',
                cancel_navigation_confirm: 'Вы уверены, что хотите прервать текущую навигацию? Вы можете выбрать новый пункт назначения.',
                navigation_cancelled: 'Навигация прервана. Вы можете спланировать новый маршрут.',
                relocating_gps: 'Перемещение GPS-позиции...',
                get_location: 'Получить местоположение',
                location_hint: 'Нажмите кнопку местоположения, чтобы получить GPS-координаты и найти ближайшие узлы',
                get_location_btn: '📍 Получить местоположение',
                get_location_btn_loading: 'Определение местоположения...',
                get_location_btn_stop: '📍 Остановить отслеживание',
                toggle_labels_all: 'Метки: Показать все',
                toggle_labels_edges_only: 'Метки: Только дороги',
                toggle_labels_nodes_only: 'Метки: Только узлы',
                toggle_labels_hidden: 'Метки: Скрыть',
                toggle_labels_all_short: 'Все',
                toggle_labels_nodes_only_short: 'Узлы',
                click_node_hint: '💡 Совет: Нажмите на узел на карте, чтобы выбрать пункт назначения',
                my_location: 'Мое местоположение',
                gps_location: 'GPS координаты',
                nearest_node: 'Ближайший узел',
                distance: 'Расстояние',
                nearby_nodes: 'Близлежащие узлы',
                location_error: 'Не удалось получить местоположение',
                location_permission_denied: 'Доступ к местоположению запрещен',
                location_unavailable: 'Местоположение недоступно',
                select_node: 'Выбрать узел',
                nearest_nodes: 'Ближайшие узлы',
                confirm_start: 'Подтвердить как точку отправления',
                location_accuracy: 'Точность',
                meters: 'метров',
                my_location: 'Мое местоположение',
                gps_location: 'GPS координаты',
                nearest_node: 'Ближайший узел',
                distance: 'Расстояние',
                nearby_nodes: 'Близлежащие узлы',
                tracking_started: 'Начато отслеживание местоположения в реальном времени',
                tracking_stopped: 'Отслеживание местоположения остановлено',
                vehicle_mode_title: 'Режим работы',
                vehicle_mode_auto: 'Автоматический режим',
                vehicle_mode_gps: 'GPS режим',
                vehicle_mode_auto_desc: 'Транспортное средство автоматически движется по маршруту с заданной скоростью',
                vehicle_mode_gps_desc: 'Позиция транспортного средства обновляется в реальном времени на основе GPS (требуется отслеживание местоположения)',
                driver_info_name: 'Имя',
                driver_info_license_plate: 'Номерной знак',
                driver_info_phone: 'Контактный телефон',
                driver_info_vehicle_type: 'Тип транспортного средства',
                driver_info_registered_at: 'Дата регистрации',
                // Новый макет
                app_title: '🚛 Планирование маршрута',
                connected: 'Подключено',
                disconnected: 'Отключено',
                driver_info_short: 'Водитель',
                mode_short: 'Режим',
                route_short: 'Маршрут',
                result_short: 'Результат',
                history_short: 'История',
                vehicle_type_truck: 'Самосвал',
                vehicle_type_material: 'Материальный грузовик',
                vehicle_type_construction: 'Строительная техника',
                vehicle_type_special: 'Специальная техника'
            }
        };

        function getVehicleSpeed(config) {
            if (!config) return 0;
            if (config.speed_kmph !== undefined) {
                const value = Number(config.speed_kmph);
                if (!Number.isNaN(value)) return value;
            }
            if (config.speed_factor !== undefined) {
                const factor = Number(config.speed_factor);
                if (!Number.isNaN(factor)) return factor * 100;
            }
            return 0;
        }

        function getSelectedVehicleSpeed() {
            const speedInput = document.getElementById('vehicle-speed');
            if (speedInput) {
                const custom = parseFloat(speedInput.value);
                if (!Number.isNaN(custom) && custom > 0) {
                    return custom;
                }
            }
            const typeSelect = document.getElementById('vehicle-type');
            const config = vehicleTypes[typeSelect?.value] || {};
            const fallback = getVehicleSpeed(config);
            return fallback > 0 ? fallback : 25;
        }

        function togglePlannerModeFields() {
            const plannerSelect = document.getElementById('planner-mode');
            const epsilonGroup = document.getElementById('dqn-epsilon-group');
            const epsilonInput = document.getElementById('dqn-epsilon');
            if (!plannerSelect || !epsilonGroup) {
                return;
            }
            if (plannerSelect.value === 'dqn') {
                epsilonGroup.style.display = 'block';
                if (epsilonInput && (epsilonInput.value === '' || Number.isNaN(parseFloat(epsilonInput.value)))) {
                    epsilonInput.value = '0.1';
                }
            } else {
                epsilonGroup.style.display = 'none';
            }
        }

        function ensureEdgeLength(edge) {
            if (!edge) return 0;
            if (edge.length_m) return Number(edge.length_m);
            if (edge.length) return Number(edge.length);
            const startNode = nodes.find(n => n.id === edge.start_node);
            const endNode = nodes.find(n => n.id === edge.end_node);
            if (startNode && endNode) {
                // GPS模式下，使用GPS坐标计算实际距离
                const modeRadios = document.querySelectorAll('.active-mode-radio');
                const selectedMode = Array.from(modeRadios).find(r => r.checked)?.value || 'auto';
                const isGpsMode = selectedMode === 'gps';
                
                if (isGpsMode && 
                    startNode.latitude !== null && startNode.latitude !== undefined && 
                    startNode.longitude !== null && startNode.longitude !== undefined &&
                    endNode.latitude !== null && endNode.latitude !== undefined && 
                    endNode.longitude !== null && endNode.longitude !== undefined) {
                    // 使用GPS坐标计算实际距离（米）
                    const lat1 = parseFloat(startNode.latitude);
                    const lon1 = parseFloat(startNode.longitude);
                    const lat2 = parseFloat(endNode.latitude);
                    const lon2 = parseFloat(endNode.longitude);
                    return calculateGpsDistance(lat1, lon1, lat2, lon2);
                } else {
                    // 非GPS模式或节点没有GPS坐标，使用地图像素距离
                const dx = endNode.x - startNode.x;
                const dy = endNode.y - startNode.y;
                return Math.sqrt(dx * dx + dy * dy);
                }
            }
            return 0;
        }

        function estimateMinutesFromDistance(distanceMeters, speedKmph) {
            const distanceKm = distanceMeters / 1000;
            const speed = speedKmph > 0 ? speedKmph : 25;
            if (distanceKm <= 0 || speed <= 0) {
                return null;
            }
            const hours = distanceKm / speed;
            return Math.max(1, Number((hours * 60).toFixed(2)));
        }

        function buildRouteFromEdges(startNodeId, targetNodeId, edges, options = {}) {
            const pathNodes = [];
            const normalizedEdges = Array.isArray(edges) ? edges : [];
            const startNode = nodes.find(n => n.id === startNodeId);
            if (startNode) {
                pathNodes.push({
                    id: startNode.id,
                    name: startNode.name,
                    type: startNode.type
                });
            } else {
                pathNodes.push({
                    id: startNodeId,
                    name: startNodeId,
                    type: 'unknown'
                });
            }

            normalizedEdges.forEach(edge => {
                const endNode = nodes.find(n => n.id === edge.end_node);
                if (endNode) {
                    pathNodes.push({
                        id: endNode.id,
                        name: endNode.name,
                        type: endNode.type
                    });
                } else if (edge.end_node) {
                    pathNodes.push({
                        id: edge.end_node,
                        name: edge.end_node,
                        type: 'unknown'
                    });
                }
            });

            const totalDistance = normalizedEdges.reduce((sum, edge) => sum + ensureEdgeLength(edge), 0);
            const selectedSpeed = options.speed && options.speed > 0 ? options.speed : getSelectedVehicleSpeed();
            const estimatedMinutes = estimateMinutesFromDistance(totalDistance, selectedSpeed);

            return {
                start_node: startNodeId,
                target_node: targetNodeId,
                path_nodes: pathNodes,
                path_edges: normalizedEdges,
                estimated_minutes: estimatedMinutes,
                planner: options.planner || 'dqn',
                custom_speed_kmph: selectedSpeed,
                distance_m: totalDistance
            };
        }

        async function requestDqnRoute(startNode, targetNode, epsilon) {
            const payload = {
                start_node: startNode,
                target_node: targetNode,
                epsilon: Math.max(0, Math.min(1, Number.isNaN(epsilon) ? 0 : epsilon))
            };
            const result = await apiCall('/dqn/route', {
                method: 'POST',
                body: JSON.stringify(payload)
            });

            if (!result.success) {
                showAlert('error', result.message || (i18n[currentLang].dqn_route_unavailable || 'DQN 路线不可用'));
                return null;
            }

            const edges = Array.isArray(result.route_edges) ? result.route_edges : [];
            if (edges.length === 0) {
                showAlert('warning', i18n[currentLang].dqn_route_unavailable || 'DQN 路线不可用，已回退系统路径');
                return null;
            }

            const route = buildRouteFromEdges(startNode, targetNode, edges, {
                planner: result.planner || 'dqn',
                speed: getSelectedVehicleSpeed()
            });
            return route;
        }

        let currentLang = 'zh';
        let nodes = [];
        let edges = [];
        let mapTextLabels = [];  // 地图文字框列表
        let vehicleTypes = {};
        let monitorData = {};
        let driverId = '';
        let currentDriverLocation = null; // 司机当前位置 {latitude, longitude, accuracy}
        let driverRoutes = [];
        let currentRoute = null; // 当前规划的路线
        let myVehicle = null; // 当前司机提交的实际车辆
        let locationWatchId = null; // 位置跟踪的watch ID
        let isLocationTracking = false; // 是否正在跟踪位置
        let vehicleMode = 'auto'; // 车辆运行模式：'auto' 或 'gps'
        let cancelledVehicleIds = new Set(); // 被中断导航的车辆ID列表（不再自动恢复）
        let gpsVehicleUpdateInterval = null; // GPS模式下更新车辆位置的定时器

        function updateArrivalButton() {
            const arrivalBtn = document.getElementById('mark-arrived');
            const submitBtn = document.getElementById('submit-vehicle');
            if (!arrivalBtn) return;
            
            // 如果有当前路线且没有活跃车辆，应该显示提交按钮，隐藏确认到达按钮
            if (currentRoute && !myVehicle) {
                arrivalBtn.style.display = 'none';
                if (submitBtn) {
                    submitBtn.style.display = 'block';
                }
                return;
            }
            
            // 如果有活跃车辆，检查是否已经确认过到达
            // 只要车辆存在且没有 arrival_time（未确认到达），就显示确认到达按钮
            // 这样可以处理延后确认的情况：即使地图显示已到达（status='arrived'），只要司机还没点击确认，按钮仍然显示
            if (myVehicle && !myVehicle.arrival_time) {
                arrivalBtn.style.display = 'block';
                arrivalBtn.disabled = false;
                arrivalBtn.textContent = i18n[currentLang].mark_arrived || '确认到达';
                if (submitBtn) {
                    submitBtn.style.display = 'none';
                }
            } else {
                // 没有活跃车辆或车辆已确认到达（有 arrival_time），隐藏确认到达按钮
                arrivalBtn.style.display = 'none';
                arrivalBtn.disabled = false;
                // 如果有路线但没车辆，显示提交按钮
                if (currentRoute && submitBtn) {
                    submitBtn.style.display = 'block';
                }
            }
        }

        function formatDistanceLabel(value) {
            const num = Number(value);
            if (!Number.isFinite(num) || num <= 0) {
                return '-';
            }
            if (num >= 1000) {
                return (num / 1000).toFixed(2) + ' km';
            }
            return num.toFixed(0) + ' m';
        }

        function formatSpeedLabel(value) {
            const num = Number(value);
            if (!Number.isFinite(num) || num <= 0) {
                return '-';
            }
            return num.toFixed(2) + ' km/h';
        }

        function getNodeDisplayName(nodeId) {
            if (!nodeId) return '-';
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return nodeId;
            return node.name ? `${node.name} (${node.id})` : node.id;
        }

        function renderActiveVehicleSummary() {
            const resultDiv = document.getElementById('route-result');
            const contentDiv = document.getElementById('result-content');
            const submitBtn = document.getElementById('submit-vehicle');
            if (!resultDiv || !contentDiv) return;

            // 如果有当前路线，优先显示路线信息（保留路线路径）
            if (currentRoute) {
                resultDiv.style.display = 'block';
                if (submitBtn) {
                    // 如果已经有车辆，说明已提交，隐藏提交按钮
                    submitBtn.style.display = myVehicle ? 'none' : 'block';
                }
                return;
            }

            if (!myVehicle) {
                if (!currentRoute) {
                    resultDiv.style.display = 'none';
                    contentDiv.innerHTML = '';
                }
                if (submitBtn) submitBtn.style.display = 'block';
                return;
            }

            const texts = i18n[currentLang];
            const statusMap = {
                zh: {
                moving: '行驶中',
                waiting: '等待中',
                queued: '排队中',
                    arrived: '已到达',
                    unknown: '未知'
                },
                en: {
                    moving: 'Moving',
                    waiting: 'Waiting',
                    queued: 'Queued',
                    arrived: 'Arrived',
                    unknown: 'Unknown'
                },
                ru: {
                    moving: 'В движении',
                    waiting: 'Ожидание',
                    queued: 'В очереди',
                    arrived: 'Прибыл',
                    unknown: 'Неизвестно'
                }
            };
            const statusTextMap = statusMap[currentLang] || statusMap['zh'];
            const startLabel = getNodeDisplayName(myVehicle.start_node);
            const targetLabel = getNodeDisplayName(myVehicle.target_node);
            const statusText = statusTextMap[myVehicle.status] || myVehicle.status || statusTextMap.unknown;
            const distanceText = formatDistanceLabel(myVehicle.planned_total_distance_m || myVehicle.total_distance_m);
            const speedValue = myVehicle.custom_speed_kmph ?? myVehicle.speed_kmph;
            const speedText = formatSpeedLabel(speedValue);
            const estimateText = myVehicle.estimated_time !== undefined && myVehicle.estimated_time !== null
                ? `${Number(myVehicle.estimated_time).toFixed(2)} 分钟`
                : (myVehicle.route_estimated_minutes ? `${Number(myVehicle.route_estimated_minutes).toFixed(2)} 分钟` : '-');

            // 尝试从车辆信息中获取路线路径
            let pathHtml = '';
            const plannedPathNodes = myVehicle.planned_path_nodes || [];
            if (plannedPathNodes.length > 0) {
                pathHtml = plannedPathNodes.map((node, index) => {
                    const nodeName = typeof node === 'string' 
                        ? getNodeDisplayName(node) 
                        : (node.name || node.id || node);
                    if (index < plannedPathNodes.length - 1) {
                        return `<div class="route-path-item">${nodeName} <span class="route-arrow">→</span></div>`;
                    }
                    return `<div class="route-path-item">${nodeName}</div>`;
                }).join('');
            }

            // 判断当前模式
            const isGpsMode = isLocationTracking && currentDriverLocation !== null;
            // texts 已在函数开头声明，这里直接使用
            const modeText = isGpsMode ? 
                `📍 ${texts.vehicle_mode_gps || 'GPS模式'}` : 
                `🚗 ${texts.vehicle_mode_auto || '自动模式'}`;
            const modeDescription = isGpsMode ? 
                (texts.vehicle_mode_gps_desc || '车辆位置根据您的GPS实时更新') : 
                (texts.vehicle_mode_auto_desc || '车辆按照设定速度自动行驶');
            
            // 车辆位置信息
            const hasPosition = myVehicle.current_position && 
                              myVehicle.current_position.x !== undefined && 
                              myVehicle.current_position.y !== undefined;
            const positionText = hasPosition ? 
                `(${myVehicle.current_position.x.toFixed(1)}, ${myVehicle.current_position.y.toFixed(1)})` : 
                '未获取';
            
            const modeLabel = texts.vehicle_mode_title || '运行模式';
            const vehicleLabel = currentLang === 'zh' ? '当前车辆' : (currentLang === 'en' ? 'Current Vehicle' : 'Текущее ТС');
            const statusLabel = texts.road_status || '状态';
            const routeLabel = currentLang === 'zh' ? '路线' : (currentLang === 'en' ? 'Route' : 'Маршрут');
            const positionLabel = currentLang === 'zh' ? '车辆位置' : (currentLang === 'en' ? 'Vehicle Position' : 'Позиция ТС');
            const timeLabel = texts.estimated_time || '预计耗时';
            const distanceLabel = currentLang === 'zh' ? '规划距离' : (currentLang === 'en' ? 'Planned Distance' : 'Плановое расстояние');
            const speedLabel = currentLang === 'zh' ? '速度' : (currentLang === 'en' ? 'Speed' : 'Скорость');
            
            contentDiv.innerHTML = `
                <div class="result-card">
                    <div class="result-item" style="background: #e8f5e9; padding: 8px; border-radius: 4px; margin-bottom: 10px;">
                        <span class="result-label" style="font-weight: bold; color: #2e7d32;">${modeLabel}:</span> 
                        <span style="font-weight: bold; color: #1b5e20;">${modeText}</span>
                        <div style="font-size: 12px; color: #666; margin-top: 4px;">${modeDescription}</div>
                    </div>
                    <div class="result-item"><span class="result-label">${vehicleLabel}:</span> ${myVehicle.id || '-'}</div>
                    <div class="result-item"><span class="result-label">${statusLabel}:</span> ${statusText}</div>
                    <div class="result-item"><span class="result-label">${routeLabel}:</span> ${startLabel} → ${targetLabel}</div>
                    <div class="result-item"><span class="result-label">${positionLabel}:</span> ${positionText}</div>
                    <div class="result-item"><span class="result-label">${timeLabel}:</span> ${estimateText}</div>
                    <div class="result-item"><span class="result-label">${distanceLabel}:</span> ${distanceText}</div>
                    <div class="result-item"><span class="result-label">${speedLabel}:</span> ${speedText}</div>
                    ${pathHtml ? `<div class="route-path"><strong>${i18n[currentLang].route_path}:</strong>${pathHtml}</div>` : ''}
                </div>
            `;

            resultDiv.style.display = 'block';
            if (submitBtn) submitBtn.style.display = 'none';
        }

        function applyVehicleTypeDefaultSpeed(force = false) {
            const select = document.getElementById('vehicle-type');
            const speedInput = document.getElementById('vehicle-speed');
            if (!select || !speedInput) return;
            const hasUserModified = speedInput.dataset.userModified === 'true';
            if (!force && hasUserModified) {
                return;
            }
            const config = vehicleTypes[select.value] || {};
            const defaultSpeed = getVehicleSpeed(config);
            if (defaultSpeed) {
                speedInput.value = defaultSpeed;
                speedInput.dataset.userModified = 'false';
            } else if (force && !hasUserModified) {
                speedInput.value = '';
                speedInput.dataset.userModified = 'false';
            }
        }

        // 使用模块中的 API_BASE（如果模块已加载）
        // API_BASE 在 js/api.js 模块中已声明，不能重新声明
        // 创建一个函数来获取 API_BASE，避免重复声明
        function getApiBaseUrl() {
            // 如果模块已加载，使用模块中的 API_BASE
            if (window.API_BASE) {
                return window.API_BASE;
            }
            // 否则使用备用实现
            const origin = window.location.origin;
            if (origin === 'null' || origin.startsWith('file://')) {
                return 'http://localhost:5000/api';
            }
            return origin + '/api';
        }
        
        // 创建一个全局变量引用（不使用 const/let，避免重复声明）
        // 使用立即执行函数创建作用域
        (function() {
            const apiBase = getApiBaseUrl();
            // 将变量暴露到全局（如果不存在）
            if (!window.API_BASE) {
                Object.defineProperty(window, 'API_BASE', {
                    get: function() {
                        return getApiBaseUrl();
                    },
                    configurable: true,
                    enumerable: true
                });
            }
        })();

        // 初始化
        async function init() {
            // 检查是否可以直接访问API
            if (window.location.protocol === 'file:') {
                showAlert('warning', '⚠️ 请通过 http:// 协议访问此页面，而不是直接打开文件。请访问: http://localhost:5000/driver 或使用局域网IP地址');
            }

            // 首先设置事件监听器，确保用户可以立即交互
            setupEventListeners();
            
            // 加载语言（同步操作，快速完成）
            await loadLanguage('zh');
            
            // 异步加载数据，不阻塞 UI
            // 使用 setTimeout 让浏览器有机会渲染初始 UI
            setTimeout(async () => {
                try {
                    await fetchNodes();
                    await fetchRoads();
                    await fetchVehicleTypes();
                    await fetchMonitorData();
                    await fetchMapLabels();
                    await loadMapRotation(); // 加载地图旋转角度
                    renderMap();
                    updateArrivalButton();
                    
                    // 从URL参数获取司机ID
                    const params = new URLSearchParams(window.location.search);
                    const id = params.get('driver_id');
                    if (id) {
                        document.getElementById('driver-id').value = id;
                        await registerDriver();
                    }
                } catch (error) {
                    console.error('数据加载失败:', error);
                    showAlert('error', '数据加载失败，请刷新页面重试');
                }
            }, 0); // 使用 setTimeout(0) 让浏览器先渲染 UI，再执行异步加载
        }
        
        // 地图旋转、缩放和拖拽功能（司机端）
        let mapRotation = 0; // 当前地图旋转角度
        let mapScale = 0.5; // 当前地图缩放比例（默认50%，让地图全部显示）
        let mapTranslateX = 0; // 当前地图平移X
        let mapTranslateY = 0; // 当前地图平移Y
        
        // 使用 requestAnimationFrame 优化地图变换更新，避免过度调用
        let updateMapTransformRafId = null;
        
        // 更新地图变换（组合旋转、缩放和平移）
        function updateMapTransform() {
            const map = document.getElementById('map');
            if (!map) return;
            
            // 取消之前的动画帧请求（防抖）
            if (updateMapTransformRafId !== null) {
                cancelAnimationFrame(updateMapTransformRafId);
            }
            
            // 使用 requestAnimationFrame 优化性能，限制在 ~60fps
            updateMapTransformRafId = requestAnimationFrame(() => {
                let transform = '';
                // 先应用旋转（如果有）
                if (mapRotation !== 0) {
                    transform += `rotate(${mapRotation}deg) `;
                }
                // 然后应用平移
                if (mapTranslateX !== 0 || mapTranslateY !== 0) {
                    transform += `translate(${mapTranslateX}px, ${mapTranslateY}px) `;
                }
                // 最后应用缩放
                transform += `scale(${mapScale})`;
                map.style.transform = transform;
                map.style.transformOrigin = '0 0';
                
                updateMapTransformRafId = null;
            });
        }
        
        // 地图居中到车辆/司机位置
        function centerMapOnVehicle() {
            const mapWrapper = document.getElementById('map-wrapper');
            if (!mapWrapper) return;
            
            const rect = mapWrapper.getBoundingClientRect();
            const containerWidth = rect.width;
            const containerHeight = rect.height;
            
            // 计算地图可见区域的中心（考虑底部面板遮挡）
            // 底部面板在半展开状态时会遮挡约50%的高度
            const bottomPanel = document.querySelector('.bottom-panel');
            let visibleHeight = containerHeight;
            if (bottomPanel) {
                const panelRect = bottomPanel.getBoundingClientRect();
                const panelTop = panelRect.top - rect.top; // 面板顶部相对于地图容器的位置
                if (panelTop > 0 && panelTop < containerHeight) {
                    visibleHeight = panelTop;
                }
            }
            
            // 屏幕中心位置（在可见区域内，稍微偏上一点）
            const screenCenterX = containerWidth / 2;
            const screenCenterY = visibleHeight / 2;
            
            let targetX = null;
            let targetY = null;
            
            // 优先使用司机GPS位置
            if (currentDriverLocation && currentDriverLocation.latitude && currentDriverLocation.longitude && nodes.length > 0) {
                const mapCoords = gpsToMapCoordinates(
                    currentDriverLocation.latitude,
                    currentDriverLocation.longitude,
                    nodes
                );
                if (mapCoords) {
                    targetX = mapCoords.x;
                    targetY = mapCoords.y;
                    console.log('📍 [居中] 使用司机GPS位置:', targetX, targetY);
                }
            }
            
            // 如果没有GPS位置，使用车辆位置
            if (targetX === null && myVehicle) {
                if (myVehicle.position) {
                    targetX = myVehicle.position.x;
                    targetY = myVehicle.position.y;
                } else if (myVehicle.x !== undefined && myVehicle.y !== undefined) {
                    targetX = myVehicle.x;
                    targetY = myVehicle.y;
                }
                console.log('🚗 [居中] 使用车辆位置:', targetX, targetY);
            }
            
            // 如果没有车辆位置，使用路线起点
            if (targetX === null && currentRoute && currentRoute.path && currentRoute.path.length > 0) {
                const startNodeId = currentRoute.path[0];
                const startNode = nodes.find(n => n.id == startNodeId);
                if (startNode) {
                    targetX = parseFloat(startNode.x);
                    targetY = parseFloat(startNode.y);
                    console.log('🚩 [居中] 使用路线起点:', targetX, targetY);
                }
            }
            
            if (targetX === null || targetY === null) {
                console.log('❌ [居中] 无法确定目标位置');
                return;
            }
            
            // 设置缩放比例为100%
            const targetScale = 1.0;
            mapScale = targetScale;
            
            // 计算平移值，使目标点显示在屏幕中心
            // CSS transform 顺序是 rotate() translate() scale()
            // 从右到左应用：先 scale，再 translate，最后 rotate
            // 对于地图点 (x, y)，最终屏幕位置 = rotate(translate(scale(x, y)))
            // = rotate((x * s + tx, y * s + ty))
            // 设 A = x * s + tx, B = y * s + ty
            // 旋转后: (A * cos(θ) - B * sin(θ), A * sin(θ) + B * cos(θ)) = (screenCenterX, screenCenterY)
            // 解方程得:
            // A = screenCenterX * cos(θ) + screenCenterY * sin(θ)
            // B = -screenCenterX * sin(θ) + screenCenterY * cos(θ)
            // tx = A - x * s, ty = B - y * s
            
            const rotation = typeof mapRotation !== 'undefined' ? mapRotation : 0;
            const rad = rotation * Math.PI / 180;
            const cosR = Math.cos(rad);
            const sinR = Math.sin(rad);
            
            const A = screenCenterX * cosR + screenCenterY * sinR;
            const B = -screenCenterX * sinR + screenCenterY * cosR;
            
            mapTranslateX = A - targetX * mapScale;
            mapTranslateY = B - targetY * mapScale;
            
            updateMapTransform();
            
            // 更新缩放显示
            const zoomLevelEl = document.getElementById('zoom-level');
            if (zoomLevelEl) {
                zoomLevelEl.textContent = Math.round(mapScale * 100) + '%';
            }
            
            console.log('✅ [居中] 地图已居中:', {
                target: { x: targetX, y: targetY },
                rotation: rotation,
                scale: mapScale,
                translate: { x: mapTranslateX, y: mapTranslateY },
                screenCenter: { x: screenCenterX, y: screenCenterY }
            });
        }
        
        // 地图居中到车辆/司机位置
        function centerMapOnVehicle() {
            const mapWrapper = document.getElementById('map-wrapper');
            if (!mapWrapper) return;
            
            const rect = mapWrapper.getBoundingClientRect();
            const containerWidth = rect.width;
            const containerHeight = rect.height;
            
            // 计算地图可见区域的中心（考虑底部面板遮挡）
            // 底部面板在半展开状态时会遮挡约50%的高度
            const bottomPanel = document.querySelector('.bottom-panel');
            let visibleHeight = containerHeight;
            if (bottomPanel) {
                const panelRect = bottomPanel.getBoundingClientRect();
                const panelTop = panelRect.top - rect.top; // 面板顶部相对于地图容器的位置
                if (panelTop > 0 && panelTop < containerHeight) {
                    visibleHeight = panelTop;
                }
            }
            
            // 屏幕中心位置（在可见区域内，稍微偏上一点）
            const screenCenterX = containerWidth / 2;
            const screenCenterY = visibleHeight / 2;
            
            let targetX = null;
            let targetY = null;
            
            // 优先使用司机GPS位置
            if (currentDriverLocation && currentDriverLocation.latitude && currentDriverLocation.longitude && nodes.length > 0) {
                const mapCoords = gpsToMapCoordinates(
                    currentDriverLocation.latitude,
                    currentDriverLocation.longitude,
                    nodes
                );
                if (mapCoords) {
                    targetX = mapCoords.x;
                    targetY = mapCoords.y;
                    console.log('📍 [居中] 使用司机GPS位置:', targetX, targetY);
                }
            }
            
            // 如果没有GPS位置，使用车辆位置
            if (targetX === null && myVehicle) {
                if (myVehicle.position) {
                    targetX = myVehicle.position.x;
                    targetY = myVehicle.position.y;
                } else if (myVehicle.x !== undefined && myVehicle.y !== undefined) {
                    targetX = myVehicle.x;
                    targetY = myVehicle.y;
                }
                console.log('🚗 [居中] 使用车辆位置:', targetX, targetY);
            }
            
            // 如果没有车辆位置，使用路线起点
            if (targetX === null && currentRoute && currentRoute.path && currentRoute.path.length > 0) {
                const startNodeId = currentRoute.path[0];
                const startNode = nodes.find(n => n.id == startNodeId);
                if (startNode) {
                    targetX = parseFloat(startNode.x);
                    targetY = parseFloat(startNode.y);
                    console.log('🚩 [居中] 使用路线起点:', targetX, targetY);
                }
            }
            
            if (targetX === null || targetY === null) {
                console.log('❌ [居中] 无法确定目标位置');
                return;
            }
            
            // 设置缩放比例为100%
            const targetScale = 1.0;
            mapScale = targetScale;
            
            // 计算平移值，使目标点显示在屏幕中心
            // CSS transform 顺序是 rotate() translate() scale()
            // 从右到左应用：先 scale，再 translate，最后 rotate
            // 对于地图点 (x, y)，最终屏幕位置 = rotate(translate(scale(x, y)))
            // = rotate((x * s + tx, y * s + ty))
            // 设 A = x * s + tx, B = y * s + ty
            // 旋转后: (A * cos(θ) - B * sin(θ), A * sin(θ) + B * cos(θ)) = (screenCenterX, screenCenterY)
            // 解方程得:
            // A = screenCenterX * cos(θ) + screenCenterY * sin(θ)
            // B = -screenCenterX * sin(θ) + screenCenterY * cos(θ)
            // tx = A - x * s, ty = B - y * s
            
            const rotation = typeof mapRotation !== 'undefined' ? mapRotation : 0;
            const rad = rotation * Math.PI / 180;
            const cosR = Math.cos(rad);
            const sinR = Math.sin(rad);
            
            const A = screenCenterX * cosR + screenCenterY * sinR;
            const B = -screenCenterX * sinR + screenCenterY * cosR;
            
            mapTranslateX = A - targetX * mapScale;
            mapTranslateY = B - targetY * mapScale;
            
            updateMapTransform();
            
            // 更新缩放显示
            const zoomLevelEl = document.getElementById('zoom-level');
            if (zoomLevelEl) {
                zoomLevelEl.textContent = Math.round(mapScale * 100) + '%';
            }
            
            console.log('✅ [居中] 地图已居中:', {
                target: { x: targetX, y: targetY },
                rotation: rotation,
                scale: mapScale,
                translate: { x: mapTranslateX, y: mapTranslateY },
                screenCenter: { x: screenCenterX, y: screenCenterY }
            });
        }
        
        // 应用地图旋转
        // 以坐标(0,0)为旋转中心
        function applyMapRotation(rotation) {
            mapRotation = rotation;
            updateMapTransform();
        }
        
        // 加载地图旋转角度
        async function loadMapRotation() {
            try {
                const apiBase = window.API_BASE || getApiBaseUrl();
                const result = await apiCall('/map-rotation', { silent: true });
                if (result && result.success && result.rotation !== undefined) {
                    mapRotation = parseFloat(result.rotation) || 0;
                    applyMapRotation(mapRotation);
                }
            } catch (error) {
                logWarn('加载地图旋转角度失败:', error);
            }
        }

        // 语言切换
        function loadLanguage(lang) {
            currentLang = lang;
            const texts = i18n[lang];
            
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (texts[key]) {
                    el.textContent = texts[key];
                } else {
                    // 如果找不到翻译，保留原始文本或使用key
                    logWarn(`未找到翻译键: ${key}`);
                }
            });
            
            // 更新定位按钮文本（特殊处理，因为包含emoji）
            const getLocationBtnText = document.getElementById('get-location-btn-text');
            if (getLocationBtnText) {
                // 检查按钮当前状态（是否正在定位）
                const getLocationBtn = document.getElementById('get-location-btn');
                if (getLocationBtn) {
                    const currentText = getLocationBtn.textContent || getLocationBtn.innerText || '';
                    if (currentText.includes('停止') || currentText.includes('Stop') || currentText.includes('Остановить')) {
                        getLocationBtnText.textContent = texts.get_location_btn_stop || '📍 停止定位';
                    } else if (currentText.includes('定位中') || currentText.includes('Locating') || currentText.includes('Определение')) {
                        getLocationBtnText.textContent = texts.get_location_btn_loading || '定位中...';
                    } else {
                        getLocationBtnText.textContent = texts.get_location_btn || '📍 定位';
                    }
                } else {
                    getLocationBtnText.textContent = texts.get_location_btn || '📍 定位';
                }
            }

            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                if (texts[key]) {
                    el.placeholder = texts[key];
                }
            });

            // 更新运行模式提示文本（特殊处理，因为包含多个部分）
            const vehicleModeHint = document.getElementById('vehicle-mode-hint');
            if (vehicleModeHint) {
                const autoLabel = vehicleModeHint.querySelector('strong[data-i18n="vehicle_mode_auto"]');
                const autoDesc = vehicleModeHint.querySelector('span[data-i18n="vehicle_mode_auto_desc"]');
                const gpsLabel = vehicleModeHint.querySelector('strong[data-i18n="vehicle_mode_gps"]');
                const gpsDesc = vehicleModeHint.querySelector('span[data-i18n="vehicle_mode_gps_desc"]');
                
                const separator = lang === 'zh' ? '：' : ': ';
                
                if (autoLabel && texts.vehicle_mode_auto) {
                    autoLabel.textContent = texts.vehicle_mode_auto + separator;
                }
                if (autoDesc && texts.vehicle_mode_auto_desc) {
                    autoDesc.textContent = separator + texts.vehicle_mode_auto_desc;
                }
                if (gpsLabel && texts.vehicle_mode_gps) {
                    gpsLabel.textContent = texts.vehicle_mode_gps + separator;
                }
                if (gpsDesc && texts.vehicle_mode_gps_desc) {
                    gpsDesc.textContent = separator + texts.vehicle_mode_gps_desc;
                }
            }

            // 更新缩放按钮的title属性
            const zoomInBtn = document.getElementById('zoom-in');
            const zoomOutBtn = document.getElementById('zoom-out');
            if (zoomInBtn && texts.zoom_in) {
                zoomInBtn.title = texts.zoom_in;
            }
            if (zoomOutBtn && texts.zoom_out) {
                zoomOutBtn.title = texts.zoom_out;
            }
            
            // 更新标签切换按钮文本（只更新.label-text部分，保持按钮结构）
            const toggleLabelsBtn = document.getElementById('toggle-labels');
            if (toggleLabelsBtn) {
                const labelTextEl = toggleLabelsBtn.querySelector('.label-text');
                const map = document.getElementById('map');
                if (labelTextEl && map) {
                    // 根据当前模式更新按钮文本
                    if (map.classList.contains('map-labels-nodes-only')) {
                        labelTextEl.textContent = texts.toggle_labels_nodes_only_short || '仅节点';
                        toggleLabelsBtn.setAttribute('data-mode', '仅节点');
                    } else {
                        labelTextEl.textContent = texts.toggle_labels_all_short || '全部';
                        toggleLabelsBtn.setAttribute('data-mode', '全部');
                    }
                }
            }

            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-lang') === lang) {
                    btn.classList.add('active');
                }
            });
            
            // 更新车辆类型选择框（重新翻译）
            if (vehicleTypes && Object.keys(vehicleTypes).length > 0) {
                updateVehicleTypeSelect();
            }
            
            // 如果当前有司机信息显示，重新显示以更新语言
            const driverInfoDisplay = document.getElementById('driver-info-display');
            if (driverInfoDisplay && driverInfoDisplay.style.display !== 'none') {
                // 尝试从全局变量获取当前司机信息
                // 如果没有，尝试从API重新获取
                const driverIdInput = document.getElementById('driver-id');
                if (driverIdInput && driverIdInput.value.trim()) {
                    loadDriverInfo(driverIdInput.value.trim());
                }
            }
        }

        // ========== 日志控制（生产环境可关闭）==========
        const DEBUG_MODE = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
        const log = DEBUG_MODE ? console.log.bind(console) : () => {};
        const logError = console.error.bind(console); // 错误始终记录
        const logWarn = DEBUG_MODE ? console.warn.bind(console) : () => {};

        // ========== 稳定性增强模块 ==========
        
        // 1. 请求限流（客户端）
        class ClientRateLimiter {
            constructor(maxRequests = 30, windowMs = 1000) {
                this.maxRequests = maxRequests;
                this.windowMs = windowMs;
                this.requests = [];
            }
            
            isAllowed() {
                const now = Date.now();
                this.requests = this.requests.filter(time => now - time < this.windowMs);
                if (this.requests.length >= this.maxRequests) {
                    return false;
                }
                this.requests.push(now);
                return true;
            }
        }
        
        const rateLimiter = new ClientRateLimiter(30, 1000);
        
        // 2. 连接状态监控
        let connectionStatus = {
            online: navigator.onLine,
            lastCheck: Date.now(),
            consecutiveFailures: 0,
            healthStatus: 'unknown'
        };
        
        // 监听网络状态
        window.addEventListener('online', () => {
            connectionStatus.online = true;
            connectionStatus.consecutiveFailures = 0;
            updateConnectionIndicator();
        });
        
        window.addEventListener('offline', () => {
            connectionStatus.online = false;
            updateConnectionIndicator();
        });
        
        // 3. 数据缓存
        const cache = {
            get(key) {
                try {
                    const item = localStorage.getItem(`cache_${key}`);
                    if (!item) return null;
                    const { data, expiry } = JSON.parse(item);
                    if (Date.now() > expiry) {
                        localStorage.removeItem(`cache_${key}`);
                        return null;
                    }
                    return data;
                } catch (e) {
                    return null;
                }
            },
            set(key, data, ttl = 300000) { // 默认5分钟
                try {
                    const item = {
                        data,
                        expiry: Date.now() + ttl
                    };
                    localStorage.setItem(`cache_${key}`, JSON.stringify(item));
                } catch (e) {
                    logWarn('缓存写入失败:', e);
                }
            },
            clear() {
                try {
                    Object.keys(localStorage).forEach(key => {
                        if (key.startsWith('cache_')) {
                            localStorage.removeItem(key);
                        }
                    });
                } catch (e) {
                    logWarn('缓存清理失败:', e);
                }
            }
        };
        
        // 4. 健康检查
        let healthCheckInterval = null;
        async function checkServerHealth() {
            try {
                const apiBase = window.API_BASE || getApiBaseUrl();
                const response = await fetch(`${apiBase}/health`, {
                    method: 'GET',
                    signal: AbortSignal.timeout(5000)
                });
                if (response.ok) {
                    const health = await response.json();
                    connectionStatus.healthStatus = health.status || 'healthy';
                    connectionStatus.consecutiveFailures = 0;
                    connectionStatus.lastCheck = Date.now();
                } else {
                    connectionStatus.healthStatus = 'unhealthy';
                    connectionStatus.consecutiveFailures++;
                }
            } catch (error) {
                connectionStatus.healthStatus = 'unreachable';
                connectionStatus.consecutiveFailures++;
            }
            updateConnectionIndicator();
        }
        
        // 5. 连接状态指示器
        function updateConnectionIndicator() {
            // 可以在这里添加UI指示器
            if (connectionStatus.consecutiveFailures > 3) {
                logWarn('服务器连接异常，连续失败次数:', connectionStatus.consecutiveFailures);
            }
        }
        
        // 6. 增强的API调用（带重试和缓存）
        // apiCall 在 js/api.js 模块中已声明，不能重新声明
        // 创建一个函数来获取或使用备用实现
        function getApiCall() {
            // 如果模块已加载，使用模块中的 apiCall
            if (window.apiCall) {
                return window.apiCall;
            }
            // 否则使用备用实现
            return async function(endpoint, options = {}) {
                const apiBase = window.API_BASE || getApiBaseUrl();
                const url = `${apiBase}${endpoint}`;
                const cacheKey = `api_${endpoint}_${JSON.stringify(options.body || {})}`;
                const useCache = options.cache !== false && options.method === 'GET';
                const maxRetries = options.maxRetries !== undefined ? options.maxRetries : 3;
                const retryDelay = options.retryDelay || 1000;
                
                // 检查缓存
                if (useCache) {
                    const cached = cache.get(cacheKey);
                    if (cached) {
                        return cached;
                    }
                }
                
                // 请求限流
                if (!rateLimiter.isAllowed()) {
                    logWarn('请求限流触发:', endpoint);
                    if (useCache) {
                        const cached = cache.get(cacheKey);
                        if (cached) return cached;
                    }
                    return { success: false, message: '请求过于频繁，请稍后再试' };
                }
                
                let lastError = null;
                for (let attempt = 0; attempt <= maxRetries; attempt++) {
                    try {
                        const startTime = performance.now();
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), options.timeout || 10000);
                        
                        const response = await fetch(url, {
                            headers: {
                                'Content-Type': 'application/json',
                                ...options.headers
                            },
                            signal: controller.signal,
                            ...options
                        });
                        
                        clearTimeout(timeoutId);
                        const duration = performance.now() - startTime;
                        
                        // 记录慢请求
                        if (duration > 2000) {
                            logWarn(`慢请求: ${endpoint} 耗时 ${duration.toFixed(2)}ms`);
                        }
                        
                        if (!response.ok) {
                            // 429 限流错误，等待后重试
                            if (response.status === 429 && attempt < maxRetries) {
                                const retryAfter = response.headers.get('Retry-After');
                                const delay = retryAfter ? parseInt(retryAfter) * 1000 : retryDelay * (attempt + 1);
                                await new Promise(resolve => setTimeout(resolve, delay));
                                continue;
                            }
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        
                        const data = await response.json();
                        
                        // 缓存成功响应
                        if (useCache && data.success) {
                            cache.set(cacheKey, data, options.cacheTTL || 300000);
                        }
                        
                        connectionStatus.consecutiveFailures = 0;
                        return data;
                        
                    } catch (error) {
                        lastError = error;
                        
                        // 如果是网络错误且还有重试次数，等待后重试
                        if (attempt < maxRetries && (error.name === 'TypeError' || error.name === 'AbortError')) {
                            const delay = retryDelay * Math.pow(2, attempt); // 指数退避
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue;
                        }
                        
                        // 最后一次尝试失败
                        if (attempt === maxRetries) {
                            connectionStatus.consecutiveFailures++;
                            logError('API调用失败:', error, 'URL:', url);
                            
                            // 尝试使用缓存
                            if (useCache) {
                                const cached = cache.get(cacheKey);
                                if (cached) {
                                    log('使用缓存数据:', endpoint);
                                    return cached;
                                }
                            }
                            
                            let errorMsg = error.message;
                            if (error.message === 'Failed to fetch' || error.name === 'TypeError') {
                                errorMsg = '无法连接到服务器。请检查网络连接或服务器状态。';
                            } else if (error.name === 'AbortError') {
                                errorMsg = '请求超时，请稍后重试。';
                            }
                            
                            // 只在非静默模式下显示错误
                            if (!options.silent) {
                                showAlert('error', i18n[currentLang].error + ': ' + errorMsg);
                            }
                            
                            return { success: false, message: errorMsg };
                        }
                    }
                }
                
                return { success: false, message: lastError?.message || '未知错误' };
            };
        }
        
        // 创建一个全局函数引用（不使用 const/let，避免重复声明）
        // 使用立即执行函数创建作用域
        (function() {
            const apiCallFn = getApiCall();
            // 将函数暴露到全局（如果不存在）
            if (!window.apiCall) {
                window.apiCall = apiCallFn;
            }
        })();
        
        // 启动健康检查（每30秒）
        if (healthCheckInterval === null) {
            healthCheckInterval = setInterval(checkServerHealth, 30000);
            checkServerHealth(); // 立即检查一次
        }

        // 获取节点列表
        async function fetchNodes() {
            const result = await apiCall('/nodes');
            if (result.success) {
                nodes = result.nodes || [];
                updateNodeSelects();
            }
        }

        // 获取道路数据
        async function fetchRoads() {
            const result = await apiCall('/roads');
            if (result.success) {
                edges = result.edges || [];
                // 如果后端返回了节点数据，更新节点（包括显示状态）
                if (result.nodes && result.nodes.length > 0) {
                    nodes = result.nodes || [];
                    updateNodeSelects();
                }
            }
        }

        // 获取车辆类型
        async function fetchVehicleTypes() {
            const result = await apiCall('/vehicle-types');
            if (result.success) {
                vehicleTypes = result.vehicle_types || {};
                Object.keys(vehicleTypes).forEach(type => {
                    const cfg = vehicleTypes[type] || {};
                    cfg.speed_kmph = getVehicleSpeed(cfg);
                    vehicleTypes[type] = cfg;
                });
                updateVehicleTypeSelect();
                applyVehicleTypeDefaultSpeed(true);
            }
        }

        // 获取地图文字框
        async function fetchMapLabels() {
            try {
                const result = await apiCall('/map-labels');
                if (result.success) {
                    mapTextLabels = result.labels || [];
                }
            } catch (error) {
                logError('获取地图文字框失败:', error);
            }
        }

        // 获取监控数据
        async function fetchMonitorData() {
            try {
                const result = await apiCall('/monitor', { silent: true }); // 使用 silent 模式，避免显示错误提示
                if (result && result.success) {
                    monitorData = result.monitor_data || {};
                    // 接收节点拥堵和道路状态
                    monitorData.node_congestion = result.node_congestion || {};
                    monitorData.edge_status = result.edge_status || {};
                    updateRoadStatus();
                    renderMap(); // 更新地图显示道路状态
                }
            } catch (error) {
                // 静默处理错误，避免影响其他功能（如语言切换）
                logWarn('获取监控数据失败:', error);
            }
        }

        // 获取车辆信息（查找属于当前司机的车辆）
        async function fetchMyVehicle() {
            if (!driverId) return;
            
            const result = await apiCall('/vehicles', { cache: false }); // 不使用缓存，确保获取最新数据
            if (result.success) {
                const vehicles = result.vehicles || [];
                // 查找该司机的车辆，只要没有确认到达（没有 arrival_time），就认为是活跃车辆
                // 这样可以处理延后确认的情况：即使地图显示已到达（status='arrived'），只要司机还没点击确认，仍然可以确认到达
                // 同时过滤掉已被中断导航的车辆
                const previousVehicle = myVehicle ? JSON.parse(JSON.stringify(myVehicle)) : null; // 深拷贝用于比较
                myVehicle = vehicles.find(v => 
                    v.driver_id === driverId && 
                    !v.arrival_time && 
                    !cancelledVehicleIds.has(v.id)  // 排除已中断导航的车辆
                ) || null;
                
                // 调试信息
                if (myVehicle) {
                    console.log('🚗 [司机端] 车辆信息更新:', {
                        id: myVehicle.id,
                        status: myVehicle.status,
                        hasPosition: !!myVehicle.current_position,
                        position: myVehicle.current_position,
                        hasPath: !!myVehicle.current_path,
                        pathLength: myVehicle.current_path?.length || 0,
                        progress: myVehicle.progress
                    });
                }
                
                // 如果车辆信息更新了，重新渲染地图
                const shouldUpdate = !previousVehicle || !myVehicle || 
                    (myVehicle.current_position?.x !== previousVehicle.current_position?.x ||
                     myVehicle.current_position?.y !== previousVehicle.current_position?.y ||
                     myVehicle.progress !== previousVehicle.progress ||
                     myVehicle.current_path?.length !== previousVehicle.current_path?.length ||
                     myVehicle.status !== previousVehicle.status);
                
                if (shouldUpdate) {
                    console.log('🔄 [司机端] 车辆信息变化，更新地图');
                    renderMap(); // 更新地图显示实际行驶路径和车辆位置
                }
                
                renderActiveVehicleSummary();
                updateArrivalButton();
            }
        }

        // 更新节点选择框（只显示与管理端地图一致的节点）
        function updateNodeSelects() {
            const startSelect = document.getElementById('start-node');
            const targetSelect = document.getElementById('target-node');
            
            if (!startSelect || !targetSelect) return;
            
            startSelect.innerHTML = '';
            targetSelect.innerHTML = '';

            // 检查是否在GPS模式且有GPS位置
            const modeRadios = document.querySelectorAll('.active-mode-radio');
            const selectedMode = Array.from(modeRadios).find(r => r.checked)?.value || 'auto';
            const isGpsMode = selectedMode === 'gps';
            const hasGpsLocation = currentDriverLocation !== null && 
                                  currentDriverLocation.latitude !== null && 
                                  currentDriverLocation.longitude !== null;
            
            // GPS模式下，如果有GPS位置，添加"当前位置（GPS）"选项
            if (isGpsMode && hasGpsLocation) {
                const currentLocationOption = document.createElement('option');
                currentLocationOption.value = '__current_gps_location__';
                currentLocationOption.textContent = '📍 当前位置（GPS）';
                currentLocationOption.selected = true;
                startSelect.appendChild(currentLocationOption);
            }

            // 只添加应该显示的节点（与管理端地图显示一致）
            nodes.forEach(node => {
                // 使用 shouldShowNode 过滤节点，确保下拉框选项与地图显示一致
                if (!shouldShowNode(node)) return;
                
                const option1 = document.createElement('option');
                option1.value = node.id;
                option1.textContent = `${node.name} (${node.id})`;
                startSelect.appendChild(option1);

                const option2 = option1.cloneNode(true);
                targetSelect.appendChild(option2);
            });
        }
        
        // 更新起点节点为GPS位置
        function updateStartNodeForGps() {
            const startSelect = document.getElementById('start-node');
            if (!startSelect) return;
            
            // 移除所有选项
            startSelect.innerHTML = '';
            
            // 添加"当前位置（GPS）"选项
            const currentLocationOption = document.createElement('option');
            currentLocationOption.value = '__current_gps_location__';
            currentLocationOption.textContent = '📍 当前位置（GPS）';
            currentLocationOption.selected = true;
            startSelect.appendChild(currentLocationOption);
            
            // 添加其他节点选项（只添加应该显示的节点）
            nodes.forEach(node => {
                // 使用 shouldShowNode 过滤节点，确保下拉框选项与地图显示一致
                if (!shouldShowNode(node)) return;
                
                const option = document.createElement('option');
                option.value = node.id;
                option.textContent = `${node.name} (${node.id})`;
                startSelect.appendChild(option);
            });
        }

        // 获取当前位置并查找附近节点
        async function getCurrentLocationAndFindNodes() {
            if (!driverId) {
                showAlert('error', i18n[currentLang].please_input + ' ' + i18n[currentLang].driver_id);
                return;
            }

            const getLocationBtn = document.getElementById('get-location-btn');
            const getLocationBtnText = document.getElementById('get-location-btn-text');
            if (getLocationBtn) {
                getLocationBtn.disabled = true;
                if (getLocationBtnText) {
                    getLocationBtnText.textContent = i18n[currentLang].get_location_btn_loading || '定位中...';
                } else {
                    getLocationBtn.textContent = i18n[currentLang].get_location_btn_loading || '定位中...';
                }
            }

            if (!navigator.geolocation) {
                showAlert('error', i18n[currentLang].location_unavailable || '您的浏览器不支持定位功能');
                if (getLocationBtn) {
                    getLocationBtn.disabled = false;
                    const getLocationBtnText = document.getElementById('get-location-btn-text');
                    if (getLocationBtnText) {
                        getLocationBtnText.textContent = i18n[currentLang].get_location_btn || '📍 定位';
                    } else {
                        getLocationBtn.textContent = i18n[currentLang].get_location_btn || '📍 定位';
                    }
                }
                return;
            }

            navigator.geolocation.getCurrentPosition(
                async (position) => {
                    const latitude = position.coords.latitude;
                    const longitude = position.coords.longitude;
                    const accuracy = position.coords.accuracy;

                    try {
                        // 更新司机位置
                        const locationResult = await apiCall(`/drivers/${driverId}/location`, {
                            method: 'POST',
                            body: JSON.stringify({
                                latitude: latitude,
                                longitude: longitude,
                                accuracy: accuracy
                            })
                        });

                        if (locationResult.success) {
                            // 保存司机当前位置
                            currentDriverLocation = {
                                latitude: latitude,
                                longitude: longitude,
                                accuracy: accuracy
                            };
                            
                            // 调试信息
                            console.log('司机位置已获取:', currentDriverLocation);
                            console.log('当前节点数:', nodes.length);
                            const nodesWithGps = nodes.filter(n => 
                                n.latitude !== null && 
                                n.latitude !== undefined && 
                                n.longitude !== null && 
                                n.longitude !== undefined
                            );
                            console.log('有GPS坐标的节点数:', nodesWithGps.length);
                            if (nodesWithGps.length > 0) {
                                console.log('GPS节点列表:', nodesWithGps.map(n => ({id: n.id, name: n.name, lat: n.latitude, lon: n.longitude})));
                            }
                            
                            // 检查是否在GPS模式
                            const modeRadiosCheck = document.querySelectorAll('.active-mode-radio');
                            const selectedMode = Array.from(modeRadiosCheck).find(r => r.checked)?.value || 'auto';
                            
                            if (selectedMode === 'gps') {
                                // GPS模式：不限制在节点上，直接使用GPS位置
                                startLocationTracking();
                                // 如果已经有车辆，开始GPS位置更新
                                if (myVehicle) {
                                    startGpsVehiclePositionUpdate();
                                }
                                
                                // 更新起点选择框，自动选择"当前位置"
                                updateStartNodeForGps();
                                showAlert('success', 'GPS定位成功，已自动设置为起点');
                            } else {
                                // 自动模式：查找附近的节点，显示选择对话框
                                const nodesResult = await apiCall(`/drivers/${driverId}/find-nodes-by-gps`, {
                                    method: 'POST',
                                    body: JSON.stringify({
                                        latitude: latitude,
                                        longitude: longitude,
                                        max_results: 5
                                    })
                                });

                                if (nodesResult.success && nodesResult.nearest_nodes && nodesResult.nearest_nodes.length > 0) {
                                    showNodeSelectionDialog(nodesResult.nearest_nodes, latitude, longitude);
                                } else {
                                    showAlert('warning', '未找到附近的节点，请手动选择起点');
                                }
                            }
                            
                            // 重新渲染地图以显示司机位置
                            renderMap();
                            
                            // 检查司机位置是否成功渲染
                            setTimeout(() => {
                                const driverMarker = document.querySelector('.driver-location-marker');
                                if (driverMarker) {
                                    console.log('司机位置标记已显示在地图上');
                                } else {
                                    console.warn('司机位置标记未显示，可能的原因：');
                                    console.warn('- GPS坐标转换失败');
                                    console.warn('- 参考节点不足（需要至少2个有GPS坐标的节点）');
                                    if (nodesWithGps.length < 2) {
                                        showAlert('warning', '需要至少2个节点设置了GPS坐标才能显示司机位置');
                                    }
                                }
                            }, 100);
                        } else {
                            showAlert('error', locationResult.message || '位置更新失败');
                        }
                    } catch (error) {
                        logError('定位处理失败:', error);
                        showAlert('error', '定位处理失败: ' + (error.message || '未知错误'));
                    } finally {
                        if (getLocationBtn) {
                            getLocationBtn.disabled = false;
                            getLocationBtn.textContent = '📍 定位';
                        }
                    }
                },
                (error) => {
                    let errorMessage = i18n[currentLang].location_error || '定位失败';
                    switch (error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage = i18n[currentLang].location_permission_denied || '定位权限被拒绝，请在浏览器设置中允许定位权限';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage = i18n[currentLang].location_unavailable || '无法获取位置信息';
                            break;
                        case error.TIMEOUT:
                            errorMessage = '定位超时，请重试';
                            break;
                    }
                    showAlert('error', errorMessage);
                    if (getLocationBtn) {
                        getLocationBtn.disabled = false;
                        getLocationBtn.textContent = '📍 定位';
                    }
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        }

        // 显示节点选择对话框
        function showNodeSelectionDialog(nearbyNodes, latitude, longitude) {
            // 创建对话框
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                border-radius: 10px;
                padding: 20px;
                max-width: 500px;
                width: 100%;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            `;

            const title = document.createElement('h3');
            title.textContent = i18n[currentLang].nearest_nodes || '附近的节点';
            title.style.cssText = 'margin-top: 0; color: #667eea; margin-bottom: 15px;';

            const locationInfo = document.createElement('p');
            // 使用DMS格式显示GPS坐标
            const latDMS = decimalToDMS(latitude, true);
            const lonDMS = decimalToDMS(longitude, false);
            const gpsLabel = i18n[currentLang].gps_location || 'GPS位置';
            locationInfo.textContent = `${gpsLabel}: ${latDMS.formatted}, ${lonDMS.formatted}`;
            locationInfo.style.cssText = 'font-size: 12px; color: #666; margin-bottom: 15px;';

            const nodesList = document.createElement('div');
            nodesList.style.cssText = 'margin-bottom: 15px;';

            nearbyNodes.forEach((node, index) => {
                const nodeItem = document.createElement('div');
                nodeItem.style.cssText = `
                    padding: 12px;
                    margin-bottom: 10px;
                    border: 2px solid ${index === 0 ? '#667eea' : '#e0e0e0'};
                    border-radius: 8px;
                    cursor: pointer;
                    transition: all 0.2s;
                    background: ${index === 0 ? '#f0f8ff' : '#f8f9fa'};
                `;

                const nodeName = document.createElement('div');
                nodeName.style.cssText = 'font-weight: bold; color: #333; margin-bottom: 5px;';
                nodeName.textContent = `${node.name || node.id} (${node.id})`;

                const nodeType = document.createElement('div');
                nodeType.style.cssText = 'font-size: 12px; color: #666; margin-bottom: 5px;';
                const typeNames = {
                    'entrance': '进场口',
                    'crossroad': '交叉口',
                    'work-area': '作业区',
                    'start': '场外起点'
                };
                nodeType.textContent = `类型: ${typeNames[node.type] || node.type || '未知'}`;

                if (node.estimated_distance_m) {
                    const distance = document.createElement('div');
                    distance.style.cssText = 'font-size: 12px; color: #667eea;';
                    distance.textContent = `预计距离: ${node.estimated_distance_m} ${i18n[currentLang].meters || '米'}`;
                    nodeItem.appendChild(distance);
                }

                nodeItem.appendChild(nodeName);
                nodeItem.appendChild(nodeType);

                nodeItem.addEventListener('click', async () => {
                    // 确认选择该节点为起点
                    try {
                        const result = await apiCall(`/drivers/${driverId}/confirm-start-node`, {
                            method: 'POST',
                            body: JSON.stringify({
                                node_id: node.id,
                                latitude: latitude,
                                longitude: longitude
                            })
                        });

                        if (result.success) {
                            // 更新起点选择框
                            const startSelect = document.getElementById('start-node');
                            if (startSelect) {
                                startSelect.value = node.id;
                            }
                            showAlert('success', result.message || '起点节点已确认');
                            dialog.remove();
                        } else {
                            showAlert('error', result.message || '确认失败');
                        }
                    } catch (error) {
                        logError('确认起点节点失败:', error);
                        showAlert('error', '确认失败: ' + (error.message || '未知错误'));
                    }
                });

                nodeItem.addEventListener('mouseenter', () => {
                    nodeItem.style.borderColor = '#667eea';
                    nodeItem.style.background = '#f0f8ff';
                });

                nodeItem.addEventListener('mouseleave', () => {
                    nodeItem.style.borderColor = index === 0 ? '#667eea' : '#e0e0e0';
                    nodeItem.style.background = index === 0 ? '#f0f8ff' : '#f8f9fa';
                });

                nodesList.appendChild(nodeItem);
            });

            const closeBtn = document.createElement('button');
            closeBtn.textContent = '关闭';
            closeBtn.style.cssText = `
                width: 100%;
                padding: 12px;
                background: #667eea;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-size: 16px;
                font-weight: bold;
            `;
            closeBtn.addEventListener('click', () => {
                dialog.remove();
            });

            content.appendChild(title);
            content.appendChild(locationInfo);
            content.appendChild(nodesList);
            content.appendChild(closeBtn);
            dialog.appendChild(content);

            // 点击背景关闭
            dialog.addEventListener('click', (e) => {
                if (e.target === dialog) {
                    dialog.remove();
                }
            });

            document.body.appendChild(dialog);
        }

        // 翻译车辆类型名称
        function translateVehicleTypeName(type) {
            if (!type) return type;
            
            const typeStr = String(type).trim();
            const typeLower = typeStr.toLowerCase();
            
            // 定义车辆类型映射表（支持中文key和英文key）
            const typeMapping = {
                // 中文key -> 标准key
                '渣土车': 'truck',
                '材料车': 'material',
                '工程车': 'construction',
                '特种车': 'special',
                // 英文key -> 标准key
                'truck': 'truck',
                'material': 'material',
                'construction': 'construction',
                'special': 'special',
                // 可能的变体
                'dumptruck': 'truck',
                'materialtruck': 'material',
                'constructionvehicle': 'construction',
                'specialvehicle': 'special'
            };
            
            // 翻译表（标准key -> 各语言显示名称）
            const translations = {
                'truck': {
                    'zh': '渣土车',
                    'en': 'Dump Truck',
                    'ru': 'Самосвал'
                },
                'material': {
                    'zh': '材料车',
                    'en': 'Material Truck',
                    'ru': 'Материальный грузовик'
                },
                'construction': {
                    'zh': '工程车',
                    'en': 'Construction Vehicle',
                    'ru': 'Строительная техника'
                },
                'special': {
                    'zh': '特种车',
                    'en': 'Special Vehicle',
                    'ru': 'Специальная техника'
                }
            };
            
            // 先尝试精确匹配（支持中文key和英文key）
            const standardKey = typeMapping[typeStr] || typeMapping[typeLower];
            
            if (standardKey && translations[standardKey]) {
                return translations[standardKey][currentLang] || translations[standardKey]['zh'];
            }
            
            // 尝试部分匹配（包含关键词）
            for (const [key, standardKey] of Object.entries(typeMapping)) {
                if (typeStr.includes(key) || key.includes(typeStr) || 
                    typeLower.includes(key.toLowerCase()) || key.toLowerCase().includes(typeLower)) {
                    if (translations[standardKey]) {
                        return translations[standardKey][currentLang] || translations[standardKey]['zh'];
                    }
                }
            }
            
            // 如果都不匹配，返回原值
            return type;
        }

        // 更新车辆类型选择框
        function updateVehicleTypeSelect() {
            const select = document.getElementById('vehicle-type');
            select.innerHTML = '';

            Object.keys(vehicleTypes).forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                const speed = getVehicleSpeed(vehicleTypes[type]);
                const translatedType = translateVehicleTypeName(type);
                option.textContent = speed ? `${translatedType} (${speed} km/h)` : translatedType;
                select.appendChild(option);
            });

            select.onchange = () => applyVehicleTypeDefaultSpeed(false);
        }

        // 显示司机信息
        function displayDriverInfo(driver) {
            const displayDiv = document.getElementById('driver-info-display');
            const contentDiv = document.getElementById('driver-info-content');
            
            if (!displayDiv || !contentDiv || !driver) return;
            
            const texts = i18n[currentLang];
            const info = [];
            
            // 翻译车辆类型
            function translateVehicleType(type) {
                if (!type) return type;
                const typeMap = {
                    'zh': {
                        'truck': '渣土车',
                        'material': '材料车',
                        'construction': '工程车',
                        'special': '特种车'
                    },
                    'en': {
                        'truck': 'Dump Truck',
                        'material': 'Material Truck',
                        'construction': 'Construction Vehicle',
                        'special': 'Special Vehicle'
                    },
                    'ru': {
                        'truck': 'Самосвал',
                        'material': 'Материальный грузовик',
                        'construction': 'Строительная техника',
                        'special': 'Специальная техника'
                    }
                };
                return typeMap[currentLang]?.[type] || type;
            }
            
            if (driver.name) {
                info.push(`<strong>${texts.driver_info_name || '姓名'}:</strong> ${driver.name}`);
            }
            if (driver.license_plate) {
                info.push(`<strong>${texts.driver_info_license_plate || '车牌号'}:</strong> ${driver.license_plate}`);
            }
            if (driver.phone || driver.contact) {
                info.push(`<strong>${texts.driver_info_phone || '联系电话'}:</strong> ${driver.phone || driver.contact}`);
            }
            if (driver.vehicle_type) {
                const translatedType = translateVehicleType(driver.vehicle_type);
                info.push(`<strong>${texts.driver_info_vehicle_type || '车辆类型'}:</strong> ${translatedType}`);
            }
            if (driver.registered_at) {
                const regDate = new Date(driver.registered_at);
                // 根据语言设置日期格式
                let dateStr = '';
                if (currentLang === 'zh') {
                    dateStr = regDate.toLocaleString('zh-CN');
                } else if (currentLang === 'en') {
                    dateStr = regDate.toLocaleString('en-US');
                } else if (currentLang === 'ru') {
                    dateStr = regDate.toLocaleString('ru-RU');
                } else {
                    dateStr = regDate.toLocaleString();
                }
                info.push(`<strong>${texts.driver_info_registered_at || '注册时间'}:</strong> ${dateStr}`);
            }
            
            if (info.length > 0) {
                contentDiv.innerHTML = info.join('<br>');
                displayDiv.style.display = 'block';
            } else {
                displayDiv.style.display = 'none';
            }
        }
        
        // 加载司机信息
        async function loadDriverInfo(driverId) {
            if (!driverId) return;
            
            try {
                const result = await apiCall(`/drivers/${driverId}`);
                if (result.success && result.driver) {
                    const driver = result.driver;
                    // 填充表单
                    if (document.getElementById('driver-name')) {
                        document.getElementById('driver-name').value = driver.name || '';
                    }
                    if (document.getElementById('driver-license-plate')) {
                        document.getElementById('driver-license-plate').value = driver.license_plate || '';
                    }
                    if (document.getElementById('driver-phone')) {
                        document.getElementById('driver-phone').value = driver.phone || driver.contact || '';
                    }
                    // 显示司机信息
                    displayDriverInfo(driver);
                }
            } catch (error) {
                logWarn('加载司机信息失败:', error);
            }
        }
        
        // 注册司机
        async function registerDriver() {
            const id = document.getElementById('driver-id').value.trim();
            if (!id) {
                showAlert('error', i18n[currentLang].please_input + ' ' + i18n[currentLang].driver_id);
                return;
            }

            driverId = id;
            const name = document.getElementById('driver-name').value.trim();
            const licensePlate = document.getElementById('driver-license-plate').value.trim();
            const phone = document.getElementById('driver-phone').value.trim();
            const customSpeedInput = document.getElementById('vehicle-speed');
            const customSpeedValue = customSpeedInput ? parseFloat(customSpeedInput.value) : NaN;

            const result = await apiCall('/drivers', {
                method: 'POST',
                body: JSON.stringify({
                    driver_id: id,
                    name: name || `司机${id}`,
                    license_plate: licensePlate,
                    phone: phone,
                    contact: phone,  // 兼容字段
                    vehicle_type: document.getElementById('vehicle-type').value,
                    weight: parseFloat(document.getElementById('vehicle-weight').value),
                    width: parseFloat(document.getElementById('vehicle-width').value),
                    custom_speed_kmph: Number.isNaN(customSpeedValue) ? undefined : customSpeedValue
                })
            });
            
            if (result.success && result.driver) {
                // 显示司机信息
                displayDriverInfo(result.driver);
                showAlert('success', result.message || '注册成功');
                
                // 折叠司机信息框并显示摘要
                const driverSection = document.getElementById('driver-section');
                const driverSummary = document.getElementById('driver-section-summary');
                if (driverSection && driverSummary) {
                    // 更新摘要信息
                    const driverName = result.driver.name || `司机${id}`;
                    const licensePlate = result.driver.license_plate || '';
                    driverSummary.innerHTML = `✅ <strong>${driverName}</strong>${licensePlate ? ` · ${licensePlate}` : ''} <span style="color: var(--primary); cursor: pointer;" onclick="document.getElementById('driver-section').classList.toggle('collapsed')">(点击展开编辑)</span>`;
                    
                    // 折叠section
                    driverSection.classList.add('collapsed');
                }
                
                // 设置自定义速度
                if (result.driver.custom_speed_kmph) {
                    const speedInput = document.getElementById('vehicle-speed');
                    if (speedInput) {
                        speedInput.value = result.driver.custom_speed_kmph;
                        speedInput.dataset.userModified = 'true';
                    }
                }
                
                // 重新注册时，清空旧的车辆信息，允许重新开始
                myVehicle = null;
                // 不清空 currentRoute，保留路线信息以便重新提交
                
                // 重置提交按钮状态（防止按钮一直显示"提交中"）
                const submitBtn = document.getElementById('submit-vehicle');
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.textContent = i18n[currentLang].submit_vehicle || '提交为实际车辆';
                    // 如果有路线，显示提交按钮
                    if (currentRoute) {
                        submitBtn.style.display = 'block';
                    }
                }
                
                // 刷新车辆信息（确保获取最新状态）
                await fetchMyVehicle();
                await fetchDriverHistory();
                updateArrivalButton();
            } else {
                showAlert('error', result.message || '注册失败');
            }
        }

        // 计算路线
        let isCalculatingRoute = false; // 防止重复点击
        
        async function calculateRoute() {
            // 防止重复点击
            if (isCalculatingRoute) {
                log('路线计算中，请稍候...');
                return;
            }
            
            if (!driverId) {
                showAlert('error', i18n[currentLang].please_input + ' ' + i18n[currentLang].driver_id);
                return;
            }

            // 检查当前模式
            const modeRadios = document.querySelectorAll('.active-mode-radio');
            const selectedMode = Array.from(modeRadios).find(r => r.checked)?.value || 'auto';
            const isGpsMode = selectedMode === 'gps';

            let startNode = document.getElementById('start-node')?.value;
            const targetNode = document.getElementById('target-node')?.value;
            
            // GPS模式下，按钮功能是"提交为实际车辆"，直接计算并提交
            // 不需要先单独计算路线再提交，一步完成

            // 检查起点是否是GPS位置
            if (startNode === '__current_gps_location__') {
                // GPS模式下，使用GPS位置作为起点
                if (!currentDriverLocation || !currentDriverLocation.latitude || !currentDriverLocation.longitude) {
                    showAlert('error', '请先点击"📍 定位"按钮获取GPS位置');
                    isCalculatingRoute = false;
                    if (calculateBtn) {
                        calculateBtn.disabled = false;
                        if (originalBtnText) {
                            calculateBtn.textContent = originalBtnText;
                        }
                    }
                    return;
                }
                
                try {
                    // 查找最近的节点作为起点节点
                    console.log('🔍 [GPS路线规划] 查找最近的节点作为起点:', {
                        latitude: currentDriverLocation.latitude,
                        longitude: currentDriverLocation.longitude
                    });
                    
                    const nearestNodeResult = await apiCall(`/drivers/${driverId}/find-nodes-by-gps`, {
                        method: 'POST',
                        body: JSON.stringify({
                            latitude: currentDriverLocation.latitude,
                            longitude: currentDriverLocation.longitude,
                            max_results: 1
                        })
                    });
                    
                    console.log('🔍 [GPS路线规划] 查找最近节点结果:', nearestNodeResult);
                    
                    if (nearestNodeResult && nearestNodeResult.success && nearestNodeResult.nearest_nodes && nearestNodeResult.nearest_nodes.length > 0) {
                        // 节点对象可能使用 id 或 node_id 字段
                        const nearestNode = nearestNodeResult.nearest_nodes[0];
                        startNode = nearestNode.node_id || nearestNode.id;
                        console.log('✅ [GPS路线规划] 使用最近节点作为起点:', startNode, '节点信息:', nearestNode);
                        
                        if (!startNode) {
                            console.error('❌ [GPS路线规划] 节点对象缺少id字段:', nearestNode);
                            showAlert('error', '节点数据格式错误，无法获取节点ID');
                            isCalculatingRoute = false;
                            if (calculateBtn) {
                                calculateBtn.disabled = false;
                                if (originalBtnText) {
                                    calculateBtn.textContent = originalBtnText;
                                }
                            }
                            return;
                        }
                    } else {
                        const errorMsg = nearestNodeResult?.message || '无法找到附近的节点';
                        console.error('❌ [GPS路线规划] 查找最近节点失败:', errorMsg, nearestNodeResult);
                        showAlert('error', '无法找到附近的节点作为起点，请手动选择起点。' + (errorMsg ? ' 错误：' + errorMsg : ''));
                        isCalculatingRoute = false;
                        if (calculateBtn) {
                            calculateBtn.disabled = false;
                            if (originalBtnText) {
                                calculateBtn.textContent = originalBtnText;
                            }
                        }
                        return;
                    }
                } catch (error) {
                    console.error('❌ [GPS路线规划] 查找最近节点异常:', error);
                    showAlert('error', '查找最近节点时发生错误: ' + (error.message || '未知错误'));
                    isCalculatingRoute = false;
                    if (calculateBtn) {
                        calculateBtn.disabled = false;
                        if (originalBtnText) {
                            calculateBtn.textContent = originalBtnText;
                        }
                    }
                    return;
                }
            }

            if (!startNode || !targetNode) {
                showAlert('error', i18n[currentLang].please_select + ' ' + i18n[currentLang].start_node + ' ' + i18n[currentLang].target_node);
                return;
            }

            if (startNode === targetNode) {
                showAlert('error', i18n[currentLang].start_node + ' ' + i18n[currentLang].target_node + ' ' + '不能相同');
                return;
            }

            // 设置计算状态
            isCalculatingRoute = true;
            const calculateBtn = document.getElementById('calculate-route');
            const originalBtnText = calculateBtn?.textContent;
            if (calculateBtn) {
                calculateBtn.disabled = true;
                calculateBtn.textContent = '计算中...';
            }

            try {
                // 清空之前的路线，准备计算新路线
                currentRoute = null;
                renderMap(); // 先清空地图上的旧路线

                const customSpeedInput = document.getElementById('vehicle-speed');
                const customSpeedValue = customSpeedInput ? parseFloat(customSpeedInput.value) : NaN;
                const plannerMode = document.getElementById('planner-mode')?.value || 'classic';

                if (plannerMode === 'dqn') {
                    const epsilonInput = document.getElementById('dqn-epsilon');
                    const epsilonValue = epsilonInput ? parseFloat(epsilonInput.value) : 0.1;
                    const dqnRoute = await requestDqnRoute(startNode, targetNode, epsilonValue);
                    if (dqnRoute) {
                        // DQN路线也需要保存到后端，以便后续提交为实际车辆
                        const saveResult = await apiCall(`/drivers/${driverId}/route-preview`, {
                            method: 'POST',
                            body: JSON.stringify({
                                start_node: startNode,
                                target_node: targetNode,
                                vehicle_type: document.getElementById('vehicle-type').value,
                                weight: parseFloat(document.getElementById('vehicle-weight').value),
                                width: parseFloat(document.getElementById('vehicle-width').value),
                                custom_speed_kmph: Number.isNaN(customSpeedValue) ? undefined : customSpeedValue,
                                // 传递DQN路线的路径信息
                                path_edges: dqnRoute.path_edges,
                                path_nodes: dqnRoute.path_nodes,
                                estimated_minutes: dqnRoute.estimated_minutes,
                                efficiency_score: dqnRoute.efficiency_score,
                                planner: 'dqn'
                            })
                        });
                        
                        if (saveResult && saveResult.success) {
                            // 合并后端返回的路线信息和DQN路线信息
                            currentRoute = {
                                ...saveResult.route,
                                planner: 'dqn',
                                path_edges: dqnRoute.path_edges || saveResult.route.path_edges,
                                path_nodes: dqnRoute.path_nodes || saveResult.route.path_nodes,
                                estimated_minutes: dqnRoute.estimated_minutes || saveResult.route.estimated_minutes,
                                efficiency_score: dqnRoute.efficiency_score || saveResult.route.efficiency_score
                            };
                            console.log('✅ [路线规划] DQN路线计算成功');
                            
                            // 检查是否为GPS模式
                            const modeRadios = document.querySelectorAll('.active-mode-radio');
                            const selectedMode = Array.from(modeRadios).find(r => r.checked)?.value || 'auto';
                            const isGpsMode = selectedMode === 'gps';
                            
                            if (isGpsMode) {
                                // GPS模式：直接提交车辆（无需确认）
                                await submitVehicle(true);
                            } else {
                                // 自动模式：显示路线结果
                                displayRouteResult(currentRoute);
                                renderMap(); // 重新渲染地图以显示路线
                                await fetchDriverHistory();
                                await fetchMonitorData();
                            }
                        } else {
                            // 如果保存失败，仍然显示DQN路线，但提示用户
                            currentRoute = dqnRoute;
                            console.log('⚠️ [路线规划] DQN路线保存失败，但仍显示路线');
                            
                            // 检查是否为GPS模式
                            const modeRadios = document.querySelectorAll('.active-mode-radio');
                            const selectedMode = Array.from(modeRadios).find(r => r.checked)?.value || 'auto';
                            const isGpsMode = selectedMode === 'gps';
                            
                            if (isGpsMode) {
                                showAlert('warning', 'DQN路线计算成功，但保存失败，无法提交为实际车辆');
                            } else {
                                displayRouteResult(dqnRoute);
                                renderMap(); // 重新渲染地图以显示路线
                                showAlert('warning', 'DQN路线已显示，但保存失败，可能无法提交为实际车辆');
                            }
                        }
                        return;
                    } else {
                        showAlert('warning', i18n[currentLang].dqn_route_unavailable || 'DQN 路线不可用，已回退系统路线');
                    }
                } else {
                    // 使用经典算法计算路线
                    console.log('🚗 [路线规划] 开始计算路线:', {
                        start_node: startNode,
                        target_node: targetNode,
                        vehicle_type: document.getElementById('vehicle-type').value,
                        weight: parseFloat(document.getElementById('vehicle-weight').value),
                        width: parseFloat(document.getElementById('vehicle-width').value),
                        custom_speed_kmph: customSpeedValue
                    });
                    
                    const result = await apiCall(`/drivers/${driverId}/route-preview`, {
                        method: 'POST',
                        body: JSON.stringify({
                            start_node: startNode,
                            target_node: targetNode,
                            vehicle_type: document.getElementById('vehicle-type').value,
                            weight: parseFloat(document.getElementById('vehicle-weight').value),
                            width: parseFloat(document.getElementById('vehicle-width').value),
                            custom_speed_kmph: Number.isNaN(customSpeedValue) ? undefined : customSpeedValue
                        })
                    });

                    console.log('🚗 [路线规划] 路线计算结果:', result);

                    if (result && result.success) {
                        console.log('✅ [路线规划] 路线计算成功，显示结果');
                        console.log('✅ [路线规划] 路线数据:', {
                            start_node: result.route?.start_node,
                            target_node: result.route?.target_node,
                            path_edges_count: result.route?.path_edges?.length || 0,
                            path_nodes_count: result.route?.path_nodes?.length || 0,
                            estimated_minutes: result.route?.estimated_minutes,
                            efficiency_score: result.route?.efficiency_score
                        });
                        
                        currentRoute = result.route; // 确保设置 currentRoute
                        
                        if (!currentRoute) {
                            console.error('❌ [路线规划] result.route 为空');
                            showAlert('error', '路线数据为空，请重试');
                            return;
                        }
                        
                        if (!currentRoute.path_edges || currentRoute.path_edges.length === 0) {
                            console.error('❌ [路线规划] path_edges 为空或不存在');
                            showAlert('error', '路线路径为空，无法显示路线');
                            return;
                        }
                        
                        // GPS模式下，计算路线后直接提交车辆，不显示路线结果
                        const modeRadios = document.querySelectorAll('.active-mode-radio');
                        const selectedMode = Array.from(modeRadios).find(r => r.checked)?.value || 'auto';
                        const isGpsMode = selectedMode === 'gps';
                        
                        if (isGpsMode) {
                            // GPS模式：计算路线后自动提交车辆（无需确认）
                            await submitVehicle(true); // 传递true跳过确认对话框
                        } else {
                            // 自动模式：显示路线结果
                            displayRouteResult(currentRoute);
                            renderMap(); // 重新渲染地图以显示路线
                            await fetchDriverHistory();
                            await fetchMonitorData();
                        }
                    } else {
                        const errorMsg = result?.message || '路线计算失败，请重试';
                        console.error('❌ [路线规划] 路线计算失败:', errorMsg, result);
                        showAlert('error', errorMsg);
                        logError('路线计算失败:', result);
                    }
                }
            } catch (error) {
                logError('路线计算异常:', error);
                showAlert('error', '路线计算时发生错误: ' + (error.message || '未知错误'));
            } finally {
                // 恢复按钮状态
                isCalculatingRoute = false;
                if (calculateBtn) {
                    calculateBtn.disabled = false;
                    if (originalBtnText) {
                        calculateBtn.textContent = originalBtnText;
                    }
                }
            }
        }

        // 显示路线结果
        function displayRouteResult(route) {
            const resultDiv = document.getElementById('route-result');
            const contentDiv = document.getElementById('result-content');
            
            // 检查当前模式
            const modeRadios = document.querySelectorAll('.active-mode-radio');
            const selectedMode = Array.from(modeRadios).find(r => r.checked)?.value || 'auto';
            const isGpsMode = selectedMode === 'gps';
            
            const plannerBadge = route.planner ? `<span class="planner-badge">${route.planner.toUpperCase()}</span>` : '';
            const titleEl = document.getElementById('route-result-title');
            
            // GPS模式下隐藏路线结果内容，只显示中断导航按钮
            if (isGpsMode) {
                if (titleEl) {
                    titleEl.style.display = 'none';
                }
                if (contentDiv) {
                    contentDiv.style.display = 'none';
                }
                
                // 隐藏提交按钮和到达按钮
                const submitBtn = document.getElementById('submit-vehicle');
                const arrivalBtn = document.getElementById('mark-arrived');
                if (submitBtn) {
                    submitBtn.style.display = 'none';
                }
                if (arrivalBtn) {
                    arrivalBtn.style.display = 'none';
                }
                
                // 只显示中断导航按钮
                const cancelBtn = document.getElementById('cancel-navigation');
                if (cancelBtn) {
                    cancelBtn.style.display = 'block';
                }
                
                resultDiv.style.display = 'block';
                currentRoute = route;
                renderMap();
                return;
            }
            
            // 自动模式：显示完整的路线结果
            if (titleEl) {
                titleEl.style.display = 'block';
                titleEl.innerHTML = `${i18n[currentLang].route_result} ${plannerBadge}`;
            }
            if (contentDiv) {
                contentDiv.style.display = 'block';
            }
            
            const startNode = nodes.find(n => n.id === route.start_node);
            const targetNode = nodes.find(n => n.id === route.target_node);
            const vehicleConfig = vehicleTypes[route.vehicle_type] || {};
            const speedValue = route.custom_speed_kmph !== undefined && route.custom_speed_kmph !== null
                ? route.custom_speed_kmph
                : getVehicleSpeed(vehicleConfig) || '';

            let pathHtml = '';
            if (route.path_nodes && route.path_nodes.length > 0) {
                pathHtml = route.path_nodes.map((node, index) => {
                    if (index < route.path_nodes.length - 1) {
                        return `<div class="route-path-item">${node.name} <span class="route-arrow">→</span></div>`;
                    }
                    return `<div class="route-path-item">${node.name}</div>`;
                }).join('');
            }

            contentDiv.innerHTML = `
                <div class="result-card">
                    <div class="result-item">
                        <span class="result-label">${i18n[currentLang].start_node}:</span>
                        ${startNode ? startNode.name : route.start_node}
                    </div>
                    <div class="result-item">
                        <span class="result-label">${i18n[currentLang].target_node}:</span>
                        ${targetNode ? targetNode.name : route.target_node}
                    </div>
                    <div class="result-item">
                        <span class="result-label">${i18n[currentLang].estimated_time}:</span>
                        ${route.estimated_minutes || 'N/A'} ${i18n[currentLang].minutes}
                    </div>
                    <div class="result-item">
                        <span class="result-label">${i18n[currentLang].efficiency_score}:</span>
                        ${route.efficiency_score ? route.efficiency_score.toFixed(2) : (route.planner === 'dqn' ? '—' : 'N/A')}
                    </div>
                    <div class="result-item">
                        <span class="result-label">${i18n[currentLang].vehicle_speed_custom || '速度'}:</span>
                        ${speedValue ? speedValue + ' km/h' : '未设置'}
                    </div>
                    <div class="route-path">
                        <strong>${i18n[currentLang].route_path}:</strong>
                        ${pathHtml}
                    </div>
                    ${route.planner === 'dqn' ? `<div class="planner-warning">${i18n[currentLang].dqn_route_warning}</div>` : ''}
                </div>
            `;

            resultDiv.style.display = 'block';
            
            // 保存当前路线并更新地图
            currentRoute = route;
            
            // 确保路线数据格式正确
            if (!currentRoute.path_edges || !Array.isArray(currentRoute.path_edges)) {
                logWarn('路线数据格式不正确，path_edges 缺失或不是数组:', currentRoute);
            }
            
            // 更新地图显示路线
            renderMap();
            
            // 显示提交按钮
            const submitBtn = document.getElementById('submit-vehicle');
            if (submitBtn) {
                submitBtn.style.display = route.planner === 'dqn' ? 'none' : 'block';
                // 确保按钮状态正确（如果之前是"提交中"，恢复为正常状态）
                submitBtn.disabled = false;
                submitBtn.textContent = i18n[currentLang].submit_vehicle || '提交为实际车辆';
            }
            updateArrivalButton();
        }

        // 提交为实际车辆（支持跳过确认）
        async function submitVehicle(skipConfirm = false) {
            if (!driverId) {
                showAlert('error', i18n[currentLang].please_input + ' ' + i18n[currentLang].driver_id);
                return;
            }

            if (!currentRoute) {
                showAlert('error', '请先计算路线');
                return;
            }

            // GPS模式下跳过确认对话框
            if (!skipConfirm && !confirm(i18n[currentLang].submit_confirm)) {
                return;
            }

            // 获取提交按钮并设置状态
            const submitBtn = document.getElementById('submit-vehicle');
            const originalText = submitBtn ? submitBtn.textContent : '';
            const originalDisabled = submitBtn ? submitBtn.disabled : false;
            
            // 设置按钮为提交中状态
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.textContent = '提交中...';
            }

            try {
                const result = await apiCall(`/drivers/${driverId}/submit-vehicle`, {
                    method: 'POST',
                    body: JSON.stringify({})
                });

                if (result.success) {
                    showAlert('success', i18n[currentLang].submit_success + ': ' + result.message);
                    if (result.vehicle) {
                        myVehicle = result.vehicle;
                        // 清除被取消的车辆ID列表（新的导航会话开始）
                        cancelledVehicleIds.clear();
                    }
                    
                    // 保留当前路线信息，用于显示路线路径
                    // 不要清空 currentRoute，这样可以在提交后继续查看路线信息
                    
                    // 根据选择的模式启动相应的功能
                    const modeRadios = document.querySelectorAll('.active-mode-radio');
                    const selectedMode = Array.from(modeRadios).find(r => r.checked)?.value || 'auto';
                    vehicleMode = selectedMode;
                    
                    if (selectedMode === 'gps') {
                        // GPS模式：如果已开启定位跟踪，开始GPS车辆位置更新
                        if (isLocationTracking && currentDriverLocation) {
                            startGpsVehiclePositionUpdate();
                        } else {
                            showAlert('info', 'GPS模式已启用，请点击"📍 定位"按钮开启GPS跟踪');
                        }
                    } else {
                        // 自动模式：确保停止GPS位置更新
                        stopGpsVehiclePositionUpdate();
                    }
                    
                    // 刷新地图以显示最新状态
                    await fetchMonitorData();
<<<<<<< HEAD
=======
                    
                    // 自动放大地图并居中到司机/车辆位置
                    centerMapOnVehicle();
                    
                    // 将面板切换到半展开状态，方便查看地图
                    const bottomPanel = document.querySelector('.bottom-panel');
                    if (bottomPanel) {
                        bottomPanel.classList.remove('expanded');
                        bottomPanel.classList.add('half');
                        bottomPanel.classList.remove('collapsed');
                    }
                    // 注意：不需要调用 fetchMyVehicle()，因为 result.vehicle 已经设置了 myVehicle
                    // 如果调用 fetchMyVehicle()，可能会因为后端清理旧车辆而找不到新车辆
                    // await fetchMyVehicle(); // 获取实际车辆信息
>>>>>>> 3f6217840caedac19671347cee77977866657b6c
                    
                    // 自动放大地图并居中到司机/车辆位置
                    centerMapOnVehicle();
                    
                    // 将面板切换到半展开状态，方便查看地图
                    const bottomPanel = document.querySelector('.bottom-panel');
                    if (bottomPanel) {
                        bottomPanel.classList.remove('expanded');
                        bottomPanel.classList.add('half');
                        bottomPanel.classList.remove('collapsed');
                    }
                    
                    // GPS模式和自动模式的不同处理
                    const isGpsMode = selectedMode === 'gps';
                    
                    if (isGpsMode) {
                        // GPS模式：隐藏路线结果内容，只显示中断导航按钮
                        const resultDiv = document.getElementById('route-result');
                        const contentDiv = document.getElementById('result-content');
                        const titleEl = document.getElementById('route-result-title');
                        const calculateBtn = document.getElementById('calculate-route');
                        
                        // 显示路线结果区域（用于显示中断导航按钮）
                        if (resultDiv) {
                            resultDiv.style.display = 'block';
                        }
                        // 隐藏路线结果的内容
                        if (titleEl) {
                            titleEl.style.display = 'none';
                        }
                        if (contentDiv) {
                            contentDiv.style.display = 'none';
                        }
                        
                        // 隐藏"提交为实际车辆"按钮（calculateBtn）和提交按钮、到达按钮
                        if (calculateBtn) {
                            calculateBtn.style.display = 'none';
                        }
                        if (submitBtn) {
                            submitBtn.style.display = 'none';
                        }
                        const arrivalBtn = document.getElementById('mark-arrived');
                        if (arrivalBtn) {
                            arrivalBtn.style.display = 'none';
                        }
                        
                        // 只显示中断导航按钮
                        const cancelBtn = document.getElementById('cancel-navigation');
                        if (cancelBtn) {
                            cancelBtn.style.display = 'block';
                        }
                    } else {
                        // 自动模式：显示完整的路线结果
                        if (currentRoute) {
                            // 更新标题，显示已提交状态
                            const titleEl = document.getElementById('route-result-title');
                            if (titleEl) {
                                const plannerBadge = currentRoute.planner ? `<span class="planner-badge">${currentRoute.planner.toUpperCase()}</span>` : '';
                                titleEl.innerHTML = `${i18n[currentLang].route_result} ${plannerBadge} <span style="color: #27ae60; font-size: 0.8em;">(已提交)</span>`;
                            }
                            // 提交成功后，先恢复按钮状态，再隐藏按钮
                            if (submitBtn) {
                                submitBtn.disabled = false;
                                submitBtn.textContent = originalText || (i18n[currentLang].submit_vehicle || '提交为实际车辆');
                            }
                            
                            // 重新显示路线结果，保留路线路径
                            displayRouteResult(currentRoute);
                            
                            // 隐藏提交按钮（因为已提交）
                            if (submitBtn) {
                                submitBtn.style.display = 'none';
                            }
                        } else {
                            // 如果没有当前路线，显示车辆摘要
                            renderActiveVehicleSummary();
                        }
                        updateArrivalButton();
                    }
                } else {
                    showAlert('error', result.message || '提交失败');
                    // 恢复按钮状态
                    if (submitBtn) {
                        submitBtn.disabled = originalDisabled;
                        submitBtn.textContent = originalText;
                    }
                }
            } catch (error) {
                logError('提交车辆失败:', error);
                showAlert('error', '提交失败: ' + (error.message || '未知错误'));
                // 恢复按钮状态
                if (submitBtn) {
                    submitBtn.disabled = originalDisabled;
                    submitBtn.textContent = originalText;
                }
            }
        }

        // 防重复提交标志
        let isSubmittingArrival = false;
        
        // 中断导航功能
        function cancelNavigation() {
            const texts = i18n[currentLang];
            
            // 确认提示
            if (!confirm(texts.cancel_navigation_confirm)) {
                return;
            }
            
            // 1. 清除当前路线
            currentRoute = null;
            
<<<<<<< HEAD
            // 2. 重置终点选择
=======
            // 2. 隐藏路线结果区域
            const resultDiv = document.getElementById('route-result');
            if (resultDiv) {
                resultDiv.style.display = 'none';
            }
            
            // 3. 重置终点选择
>>>>>>> 3f6217840caedac19671347cee77977866657b6c
            const targetSelect = document.getElementById('target-node');
            if (targetSelect) {
                targetSelect.value = '';
            }
            
<<<<<<< HEAD
            // 3. 清除已提交车辆的本地引用，并记录被取消的车辆ID
=======
            // 4. 清除已提交车辆的本地引用，并记录被取消的车辆ID
>>>>>>> 3f6217840caedac19671347cee77977866657b6c
            if (myVehicle) {
                console.log('🚫 中断导航，清除本地车辆引用:', myVehicle.id);
                cancelledVehicleIds.add(myVehicle.id); // 记录被取消的车辆ID，防止自动恢复
                myVehicle = null;
            }
            
<<<<<<< HEAD
            // 4. 更新按钮状态
            const submitBtn = document.getElementById('submit-vehicle');
            const arrivalBtn = document.getElementById('mark-arrived');
            const cancelBtn = document.getElementById('cancel-navigation');
            const resultDiv = document.getElementById('route-result');
            const contentDiv = document.getElementById('result-content');
            const titleEl = document.getElementById('route-result-title');
            
            // 检查当前模式
            const vehicleModeValue = document.querySelector('.active-mode-radio:checked')?.value || 'auto';
            const isGpsMode = vehicleModeValue === 'gps';
            
            if (isGpsMode) {
                // GPS模式：中断导航后，按钮恢复为"提交为实际车辆"
                const calculateBtn = document.getElementById('calculate-route');
                if (calculateBtn) {
                    calculateBtn.textContent = texts.submit_vehicle || '✅ 提交为实际车辆';
                    calculateBtn.disabled = false;
                    calculateBtn.style.display = 'block'; // 重新显示按钮
                }
                
                // 隐藏路线结果区域
                if (resultDiv) {
                    resultDiv.style.display = 'none';
                }
                if (contentDiv) {
                    contentDiv.style.display = 'none';
                }
                if (titleEl) {
                    titleEl.style.display = 'none';
                }
                
                // 隐藏提交和到达按钮
                if (submitBtn) {
                    submitBtn.style.display = 'none';
                }
                if (arrivalBtn) {
                    arrivalBtn.style.display = 'none';
                }
                if (cancelBtn) {
                    cancelBtn.style.display = 'none';
                }
            } else {
                // 自动模式：显示提交按钮
                if (submitBtn) {
                    submitBtn.style.display = 'block';
                    submitBtn.disabled = false;
                    submitBtn.textContent = texts.submit_vehicle || '✅ 提交为实际车辆';
                }
                if (arrivalBtn) {
                    arrivalBtn.style.display = 'none';
                }
=======
            // 5. 更新按钮状态
            const submitBtn = document.getElementById('submit-vehicle');
            const arrivalBtn = document.getElementById('mark-arrived');
            if (submitBtn) {
                submitBtn.style.display = 'block';
                submitBtn.disabled = false;
                submitBtn.textContent = texts.submit_vehicle || '✅ 提交为实际车辆';
            }
            if (arrivalBtn) {
                arrivalBtn.style.display = 'none';
>>>>>>> 3f6217840caedac19671347cee77977866657b6c
            }
            
            // 6. 重新渲染地图（清除路线高亮）
            renderMap();
            
            // 7. 根据当前模式重新定位起点
<<<<<<< HEAD
=======
            const vehicleModeValue = document.querySelector('.active-mode-radio:checked')?.value || 'auto';
            
>>>>>>> 3f6217840caedac19671347cee77977866657b6c
            if (vehicleModeValue === 'gps') {
                // GPS模式：重新获取GPS位置并更新起点
                showAlert('info', texts.navigation_cancelled + ' ' + (texts.relocating_gps || '正在重新获取GPS位置...'));
                getCurrentLocationAndFindNodes();
            } else {
                // 自动模式：保持当前起点不变，或重置为默认起点
                const startSelect = document.getElementById('start-node');
                if (startSelect && !startSelect.value) {
                    // 如果起点为空，选择第一个可用起点
                    const firstOption = startSelect.querySelector('option[value]:not([value=""])');
                    if (firstOption) {
                        startSelect.value = firstOption.value;
                    }
                }
                showAlert('info', texts.navigation_cancelled);
            }
            
            // 8. 将底部面板设置为半展开状态，方便重新规划
            const bottomPanel = document.querySelector('.bottom-panel');
            if (bottomPanel) {
                bottomPanel.setAttribute('data-state', 'half');
            }
            
            // 9. 滚动到路线规划区域
            const routePlanningSection = document.querySelector('.section-title[data-i18n="route_planning"]');
            if (routePlanningSection) {
                routePlanningSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        async function markVehicleArrived() {
            // 防止重复提交
            if (isSubmittingArrival) {
                showAlert('warning', '正在提交中，请稍候...');
                return;
            }
            
            if (!driverId) {
                showAlert('error', i18n[currentLang].please_input + ' ' + i18n[currentLang].driver_id);
                return;
            }
            
            const arrivalBtn = document.getElementById('mark-arrived');
            if (arrivalBtn) {
                arrivalBtn.disabled = true;
                arrivalBtn.textContent = '提交中...';
            }
            
            isSubmittingArrival = true;
            
            try {
                const payload = {};
                if (myVehicle && myVehicle.id) {
                    payload.vehicle_id = myVehicle.id;
                }

                const result = await apiCall(`/drivers/${driverId}/arrival`, {
                    method: 'POST',
                    body: JSON.stringify(payload)
                });

                if (result.success) {
                    let message = result.message || '到达记录已保存';
                    if (result.travel_record) {
                        const travel = result.travel_record;
                        const durationValue = Number(travel.duration_minutes);
                        const distanceValue = Number(travel.distance_m);
                        const averageSpeedValue = Number(travel.average_speed_kmph);
                        const durationText = Number.isFinite(durationValue)
                            ? `${durationValue.toFixed(2)} 分钟`
                            : `${travel.duration_minutes} 分钟`;
                        const distanceText = formatDistanceLabel(distanceValue);
                        const avgSpeedText = formatSpeedLabel(averageSpeedValue);
                        const routeLabel = `${travel.start_node || '-'} → ${travel.target_node || '-'}`;
                        message += `\n路线: ${routeLabel}\n实际耗时: ${durationText}\n距离: ${distanceText}\n平均速度: ${avgSpeedText}`;
                    }
                    showAlert('success', message);
                    
                    // 清空车辆信息（只清空已到达的车辆）
                    myVehicle = null;
                    // 注意：不清空 currentRoute，保留路线信息以便重新提交
                    // currentRoute = null;
                    
                    // 更新UI
                    updateArrivalButton();
                    renderActiveVehicleSummary();
                    
                    // 刷新数据
                    await fetchMonitorData();
                    await fetchDriverHistory();
                    
                    // 成功后隐藏确认到达按钮，显示提交按钮（如果有路线）
                    if (arrivalBtn) {
                        arrivalBtn.style.display = 'none';
                        arrivalBtn.disabled = false; // 恢复禁用状态
                        arrivalBtn.textContent = i18n[currentLang].mark_arrived || '确认到达'; // 恢复文本
                    }
                    const submitBtn = document.getElementById('submit-vehicle');
                    if (submitBtn && currentRoute) {
                        submitBtn.style.display = 'block';
                        // 确保提交按钮状态正确（恢复文本和禁用状态）
                        submitBtn.disabled = false;
                        submitBtn.textContent = i18n[currentLang].submit_vehicle || '提交为实际车辆';
                    }
                    
                    // 不再自动刷新页面，让用户可以继续使用
                    // setTimeout(() => {
                    //     // 刷新当前页面以获取最新状态
                    //     window.location.reload();
                    // }, 1500);
                } else {
                    showAlert('error', result.message || '到达确认失败');
                    // 失败后保持按钮禁用3秒，防止快速重复点击
                    if (arrivalBtn) {
                        setTimeout(() => {
                            arrivalBtn.disabled = false;
                            arrivalBtn.textContent = i18n[currentLang].mark_arrived || '确认到达';
                        }, 3000);
                    }
                }
            } catch (error) {
                logError('确认到达失败:', error);
                showAlert('error', '网络错误，请稍后重试');
                // 失败后保持按钮禁用3秒
                if (arrivalBtn) {
                    setTimeout(() => {
                        arrivalBtn.disabled = false;
                        arrivalBtn.textContent = i18n[currentLang].mark_arrived || '确认到达';
                    }, 3000);
                }
            } finally {
                isSubmittingArrival = false;
            }
        }

        // 开始GPS位置跟踪
        function startLocationTracking() {
            if (isLocationTracking) {
                return; // 已经在跟踪
            }
            
            if (!navigator.geolocation) {
                showAlert('error', '您的浏览器不支持定位功能');
                return;
            }
            
            isLocationTracking = true;
            const getLocationBtn = document.getElementById('get-location-btn');
            const getLocationBtnText = document.getElementById('get-location-btn-text');
            if (getLocationBtn) {
                if (getLocationBtnText) {
                    getLocationBtnText.textContent = i18n[currentLang].get_location_btn_stop || '📍 停止定位';
                } else {
                    getLocationBtn.textContent = i18n[currentLang].get_location_btn_stop || '📍 停止定位';
                }
            }
            
            // 记录上次位置，用于检测位置变化
            let lastLatitude = null;
            let lastLongitude = null;
            const MIN_DISTANCE_CHANGE = 0.00001; // 最小变化距离（约1米），用于检测位置是否真正变化
            
            locationWatchId = navigator.geolocation.watchPosition(
                async (position) => {
                    const latitude = position.coords.latitude;
                    const longitude = position.coords.longitude;
                    const accuracy = position.coords.accuracy;
                    
                    // 计算位置变化距离（使用简单的欧几里得距离）
                    let positionChanged = false;
                    if (lastLatitude !== null && lastLongitude !== null) {
                        const latDiff = latitude - lastLatitude;
                        const lonDiff = longitude - lastLongitude;
                        const distance = Math.sqrt(latDiff * latDiff + lonDiff * lonDiff);
                        positionChanged = distance > MIN_DISTANCE_CHANGE;
                        
                        console.log('📍 [GPS更新] 位置变化检测:', {
                            distance: (distance * 111000).toFixed(2) + '米', // 转换为米
                            changed: positionChanged,
                            old: { lat: lastLatitude, lon: lastLongitude },
                            new: { lat: latitude, lon: longitude }
                        });
                    } else {
                        // 第一次获取位置，总是更新
                        positionChanged = true;
                    }
                    
                    // 只有当位置真正变化时才更新
                    if (positionChanged) {
                        // 更新司机位置
                        currentDriverLocation = {
                            latitude: latitude,
                            longitude: longitude,
                            accuracy: accuracy
                        };
                        
                        console.log('📍 [GPS更新] 司机位置已更新:', {
                            latitude: latitude,
                            longitude: longitude,
                            accuracy: accuracy ? accuracy.toFixed(2) + '米' : '未知',
                            timestamp: new Date().toLocaleTimeString()
                        });
                        
                        // 更新司机位置到后端
                        try {
                            await apiCall(`/drivers/${driverId}/location`, {
                                method: 'POST',
                                body: JSON.stringify({
                                    latitude: latitude,
                                    longitude: longitude,
                                    accuracy: accuracy
                                })
                            });
                        } catch (error) {
                            logWarn('更新司机位置失败:', error);
                        }
                        
                        // 重新渲染地图以显示司机位置
                        console.log('📍 [GPS更新] 调用renderMap()重新渲染地图');
                        renderMap();
                        
                        // 如果选择了GPS模式且有车辆，更新车辆位置
                        if (vehicleMode === 'gps' && myVehicle) {
                            await updateVehiclePositionFromGps(latitude, longitude);
                        }
                        
                        // 更新上次位置
                        lastLatitude = latitude;
                        lastLongitude = longitude;
                    } else {
                        console.log('📍 [GPS更新] 位置未变化，跳过更新');
                    }
                },
                (error) => {
                    logError('GPS跟踪错误:', error);
                    // 显示详细的错误信息用于调试
                    if (error.code === error.PERMISSION_DENIED) {
                        console.error('📍 [GPS错误] 定位权限被拒绝，请允许浏览器访问位置信息');
                    } else if (error.code === error.POSITION_UNAVAILABLE) {
                        console.error('📍 [GPS错误] 位置信息不可用，可能是WiFi定位精度不足，建议在室外使用GPS');
                    } else if (error.code === error.TIMEOUT) {
                        console.error('📍 [GPS错误] 定位超时，请检查网络连接或GPS信号');
                    }
                },
                {
                    enableHighAccuracy: true, // 启用高精度定位（优先使用GPS而不是WiFi）
                    timeout: 15000, // 增加超时时间到15秒
                    maximumAge: 0 // 强制获取新位置，不使用缓存
                }
            );
        }
        
        // 停止GPS位置跟踪
        function stopLocationTracking() {
            if (!isLocationTracking) {
                return;
            }
            
            if (locationWatchId !== null) {
                navigator.geolocation.clearWatch(locationWatchId);
                locationWatchId = null;
            }
            
            isLocationTracking = false;
            const getLocationBtn = document.getElementById('get-location-btn');
            const getLocationBtnText = document.getElementById('get-location-btn-text');
            if (getLocationBtn) {
                if (getLocationBtnText) {
                    getLocationBtnText.textContent = i18n[currentLang].get_location_btn || '📍 定位';
                } else {
                    getLocationBtn.textContent = i18n[currentLang].get_location_btn || '📍 定位';
                }
            }
            
            // 停止GPS车辆位置更新
            stopGpsVehiclePositionUpdate();
        }
        
        // 开始GPS模式下的车辆位置更新
        function startGpsVehiclePositionUpdate() {
            if (gpsVehicleUpdateInterval) {
                return; // 已经在更新
            }
            
            if (!myVehicle || !isLocationTracking || !currentDriverLocation) {
                return; // 没有车辆或没有GPS位置
            }
            
            // 立即更新一次
            updateVehiclePositionFromGps(currentDriverLocation.latitude, currentDriverLocation.longitude);
            
            // 每2秒更新一次车辆位置
            gpsVehicleUpdateInterval = setInterval(async () => {
                if (myVehicle && isLocationTracking && currentDriverLocation) {
                    await updateVehiclePositionFromGps(currentDriverLocation.latitude, currentDriverLocation.longitude);
                } else {
                    stopGpsVehiclePositionUpdate();
                }
            }, 2000);
        }
        
        // 停止GPS模式下的车辆位置更新
        function stopGpsVehiclePositionUpdate() {
            if (gpsVehicleUpdateInterval) {
                clearInterval(gpsVehicleUpdateInterval);
                gpsVehicleUpdateInterval = null;
            }
        }
        
        // 计算点到线段的GPS距离（米）
        // 返回 {distance: 距离（米）, closestPoint: {lat, lon} 最近点GPS坐标, edge: 边对象}
        function calculateGpsDistanceToEdge(latitude, longitude, edge) {
            const startNode = nodes.find(n => n.id === edge.start_node);
            const endNode = nodes.find(n => n.id === edge.end_node);
            
            if (!startNode || !endNode) {
                return null;
            }
            
            // 检查节点是否有GPS坐标
            const startLat = parseFloat(startNode.latitude);
            const startLon = parseFloat(startNode.longitude);
            const endLat = parseFloat(endNode.latitude);
            const endLon = parseFloat(endNode.longitude);
            
            if (isNaN(startLat) || isNaN(startLon) || isNaN(endLat) || isNaN(endLon)) {
                // 如果没有GPS坐标，无法准确计算GPS距离
                return null;
            }
            
            // 将GPS坐标转换为地图坐标进行计算（更高效）
            // 先转换所有坐标到地图坐标系
            const startMap = { x: startNode.x, y: startNode.y };
            const endMap = { x: endNode.x, y: endNode.y };
            
            // 将当前GPS坐标转换为地图坐标
            const currentMap = gpsToMapCoordinates(latitude, longitude, nodes);
            if (!currentMap) {
                return null;
            }
            
            // 在地图坐标系中计算点到线段的最近点
            const dx = endMap.x - startMap.x;
            const dy = endMap.y - startMap.y;
            const segmentLength2 = dx * dx + dy * dy;
            
            if (segmentLength2 < 1e-6) {
                // 线段长度为0，直接计算点到点的GPS距离
                const dist = calculateGpsDistance(latitude, longitude, startLat, startLon);
                return {
                    distance: dist,
                    closestPoint: { lat: startLat, lon: startLon },
                    edge: edge,
                    t: 0
                };
            }
            
            // 点到起点的向量
            const px = currentMap.x - startMap.x;
            const py = currentMap.y - startMap.y;
            
            // 计算投影参数 t (0-1之间表示在线段上)
            const t = Math.max(0, Math.min(1, (px * dx + py * dy) / segmentLength2));
            
            // 在地图坐标系中的最近点
            const closestMapX = startMap.x + t * dx;
            const closestMapY = startMap.y + t * dy;
            
            // 将最近点的地图坐标转换回GPS坐标
            // 使用线性插值基于两个端点的GPS坐标
            const closestLat = startLat + t * (endLat - startLat);
            const closestLon = startLon + t * (endLon - startLon);
            
            // 计算GPS距离（米）
            const distance = calculateGpsDistance(latitude, longitude, closestLat, closestLon);
            
            return {
                distance: distance,
                closestPoint: { lat: closestLat, lon: closestLon },
                edge: edge,
                t: t,
                mapPoint: { x: closestMapX, y: closestMapY }
            };
        }
        
        // 找到最近的边（道路），优先主路段
        // 返回 {distance: 距离（米）, closestPoint: {lat, lon}, edge: 边对象} 或 null
        function findNearestRoad(latitude, longitude, maxDistance = 5.0) {
            if (!edges || edges.length === 0) {
                return null;
            }
            
            const candidates = [];
            
            // 遍历所有边，计算距离
            edges.forEach(edge => {
                // 跳过封闭的道路
                const edgeStatus = monitorData.edge_status && monitorData.edge_status[edge.id];
                const available = monitorData.edge_available && monitorData.edge_available[edge.id] !== undefined 
                    ? monitorData.edge_available[edge.id] 
                    : edge.is_available;
                if (!available || edgeStatus === 'closed') {
                    return; // 跳过封闭道路
                }
                
                const result = calculateGpsDistanceToEdge(latitude, longitude, edge);
                if (result && result.distance <= maxDistance) {
                    candidates.push(result);
                }
            });
            
            if (candidates.length === 0) {
                return null;
            }
            
            // 优先选择主路段（road_type === 'main'）
            const mainRoads = candidates.filter(c => c.edge.road_type === 'main');
            if (mainRoads.length > 0) {
                // 在主路段中选择最近的
                mainRoads.sort((a, b) => a.distance - b.distance);
                return mainRoads[0];
            }
            
            // 如果没有主路段，选择最近的支路
            candidates.sort((a, b) => a.distance - b.distance);
            return candidates[0];
        }
        
        // 根据GPS位置更新车辆位置
        async function updateVehiclePositionFromGps(latitude, longitude) {
            if (!myVehicle || !driverId) {
                return;
            }
            
            try {
                // 尝试吸附到道路上（GPS模式下）
                let finalLatitude = latitude;
                let finalLongitude = longitude;
                let snappedToRoad = false;
                let mapCoords = null;
                
                // 查找最近的道路（优先主路段，最大距离5米）
                const nearestRoad = findNearestRoad(latitude, longitude, 5.0);
                
                if (nearestRoad) {
                    // 吸附到道路上
                    finalLatitude = nearestRoad.closestPoint.lat;
                    finalLongitude = nearestRoad.closestPoint.lon;
                    snappedToRoad = true;
                    
                    // 如果吸附结果中有地图坐标，直接使用（更精确）
                    if (nearestRoad.mapPoint) {
                        mapCoords = nearestRoad.mapPoint;
                    }
                    
                    console.log(`📍 [GPS道路吸附] 位置已吸附到道路:`, {
                        original: { lat: latitude.toFixed(7), lon: longitude.toFixed(7) },
                        snapped: { lat: finalLatitude.toFixed(7), lon: finalLongitude.toFixed(7) },
                        distance: nearestRoad.distance.toFixed(2) + '米',
                        roadType: nearestRoad.edge.road_type === 'main' ? '主路段' : '支路',
                        edgeId: nearestRoad.edge.id,
                        edgeName: nearestRoad.edge.name || nearestRoad.edge.id
                    });
                }
                
                // 如果没有通过吸附获得地图坐标，则通过GPS坐标转换
                if (!mapCoords) {
                    mapCoords = gpsToMapCoordinates(finalLatitude, finalLongitude, nodes);
                    if (!mapCoords) {
                        logWarn('无法将GPS坐标转换为地图坐标');
                        return;
                    }
                }
                
                // 更新车辆位置到后端
                const result = await apiCall(`/vehicles/${myVehicle.id}/position`, {
                    method: 'POST',
                    body: JSON.stringify({
                        x: mapCoords.x,
                        y: mapCoords.y,
                        latitude: finalLatitude,  // 使用吸附后的坐标
                        longitude: finalLongitude, // 使用吸附后的坐标
                        mode: 'gps' // 标记为GPS模式
                    })
                });
                
                if (result.success) {
                    // 更新本地车辆位置
                    if (myVehicle) {
                        myVehicle.current_position = {
                            x: mapCoords.x,
                            y: mapCoords.y
                        };
                        myVehicle.gps_latitude = finalLatitude;
                        myVehicle.gps_longitude = finalLongitude;
                        // 保存原始GPS坐标（用于显示）
                        myVehicle.original_gps_latitude = latitude;
                        myVehicle.original_gps_longitude = longitude;
                        myVehicle.snapped_to_road = snappedToRoad;
                    }
                    
                    // 重新渲染地图
                    renderMap();
                } else {
                    logWarn('更新车辆位置失败:', result.message);
                }
            } catch (error) {
                logError('更新车辆位置异常:', error);
            }
        }
        
        // GPS坐标到地图坐标转换函数（使用纯粹的线性变换，保持相对位置关系）
        // 基于所有有GPS坐标的参考节点，计算线性变换参数（缩放+平移）
        function gpsToMapCoordinates(latitude, longitude, nodes) {
            // 找到所有有GPS坐标的节点作为参考点
            const referenceNodes = nodes.filter(n => {
                const hasLat = n.latitude !== null && n.latitude !== undefined && !isNaN(parseFloat(n.latitude));
                const hasLon = n.longitude !== null && n.longitude !== undefined && !isNaN(parseFloat(n.longitude));
                return hasLat && hasLon;
            });
            
            console.log('GPS坐标转换 - 参考节点数:', referenceNodes.length);
            console.log('GPS坐标转换 - 司机GPS:', latitude, longitude);
            
            if (referenceNodes.length < 2) {
                console.warn('GPS坐标转换失败: 参考节点不足（需要至少2个）');
                return null;
            }
            
            // 准备参考节点数据
            const refPoints = referenceNodes.map(node => ({
                lat: parseFloat(node.latitude),
                lon: parseFloat(node.longitude),
                x: parseFloat(node.x),
                y: parseFloat(node.y)
            }));
            
            // 计算GPS坐标的范围（用于计算缩放因子和平移）
            const lats = refPoints.map(p => p.lat);
            const lons = refPoints.map(p => p.lon);
            const xs = refPoints.map(p => p.x);
            const ys = refPoints.map(p => p.y);
            
            const minLat = Math.min(...lats);
            const maxLat = Math.max(...lats);
            const minLon = Math.min(...lons);
            const maxLon = Math.max(...lons);
            
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);
            
            // 计算GPS坐标的范围（度数）
            const gpsRangeLat = maxLat - minLat;
            const gpsRangeLon = maxLon - minLon;
            
            // 计算地图坐标的范围（像素）
            const mapRangeX = maxX - minX;
            const mapRangeY = maxY - minY;
            
            // 分别计算经度到X坐标、纬度到Y坐标的缩放因子
            let scaleX = 1;
            let scaleY = 1;
            
            if (gpsRangeLon > 1e-10) {
                scaleX = mapRangeX / gpsRangeLon;
            } else {
                console.warn('GPS坐标转换 - 经度范围太小，使用默认缩放');
            }
            
            if (gpsRangeLat > 1e-10) {
                scaleY = mapRangeY / gpsRangeLat;
            } else {
                console.warn('GPS坐标转换 - 纬度范围太小，使用默认缩放');
            }
            
            // 验证缩放因子是否合理
            if (scaleX < 0.1 || scaleX > 100000 || scaleY < 0.1 || scaleY > 100000) {
                console.warn('GPS坐标转换 - 缩放因子异常:', { scaleX, scaleY }, '使用默认值');
                scaleX = 1;
                scaleY = 1;
            }
            
            // 使用最小二乘法计算最佳的线性变换参数
            // 线性变换公式：mapX = a * lon + b
            //                mapY = c * lat + d
            
            // 计算平均值
            const avgLon = lons.reduce((sum, lon) => sum + lon, 0) / lons.length;
            const avgLat = lats.reduce((sum, lat) => sum + lat, 0) / lats.length;
            const avgX = xs.reduce((sum, x) => sum + x, 0) / xs.length;
            const avgY = ys.reduce((sum, y) => sum + y, 0) / ys.length;
            
            // 计算最小二乘法的参数
            // a = Σ((lon_i - lon_mean) * (x_i - x_mean)) / Σ((lon_i - lon_mean)^2)
            let numeratorX = 0;
            let denominatorX = 0;
            let numeratorY = 0;
            let denominatorY = 0;
                
                refPoints.forEach(ref => {
                const dLon = ref.lon - avgLon;
                const dLat = ref.lat - avgLat;
                const dX = ref.x - avgX;
                const dY = ref.y - avgY;
                
                numeratorX += dLon * dX;
                denominatorX += dLon * dLon;
                numeratorY += dLat * dY;
                denominatorY += dLat * dLat;
            });
            
            // 计算缩放因子（斜率）
            let finalScaleX = scaleX;
            let finalScaleY = scaleY;
            
            if (Math.abs(denominatorX) > 1e-10) {
                finalScaleX = numeratorX / denominatorX;
            }
            
            if (Math.abs(denominatorY) > 1e-10) {
                finalScaleY = numeratorY / denominatorY;
            }
            
            // 计算偏移量（截距）
            // b = x_mean - a * lon_mean
            // d = y_mean - c * lat_mean
            const offsetX = avgX - finalScaleX * avgLon;
            const offsetY = avgY - finalScaleY * avgLat;
            
            // 应用线性变换：mapX = lon * finalScaleX + offsetX
            //                mapY = lat * finalScaleY + offsetY
            const mapX = longitude * finalScaleX + offsetX;
            const mapY = latitude * finalScaleY + offsetY;
            
            console.log('GPS坐标转换结果（线性变换-最小二乘法）:', {
                referenceNodesCount: refPoints.length,
                gpsRange: { lat: gpsRangeLat.toFixed(8) + '°', lon: gpsRangeLon.toFixed(8) + '°' },
                mapRange: { x: mapRangeX.toFixed(2) + 'px', y: mapRangeY.toFixed(2) + 'px' },
                scale: { x: finalScaleX.toFixed(2) + ' px/°', y: finalScaleY.toFixed(2) + ' px/°' },
                offset: { x: offsetX.toFixed(2) + 'px', y: offsetY.toFixed(2) + 'px' },
                driver: { lat: latitude, lon: longitude },
                result: { x: mapX.toFixed(2), y: mapY.toFixed(2) }
            });
            
            return { x: mapX, y: mapY };
        }
        
        // 计算两点之间的GPS距离（米）
        function calculateGpsDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // 地球半径（米）
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }
        
        // 十进制度数转度分秒 (Decimal Degrees to Degrees Minutes Seconds)
        function decimalToDMS(decimal, isLatitude) {
            const absolute = Math.abs(decimal);
            const degrees = Math.floor(absolute);
            const minutesFloat = (absolute - degrees) * 60;
            const minutes = Math.floor(minutesFloat);
            const seconds = (minutesFloat - minutes) * 60;
            
            let direction = '';
            if (isLatitude) {
                direction = decimal >= 0 ? 'N' : 'S';
            } else {
                direction = decimal >= 0 ? 'E' : 'W';
            }
            
            return {
                degrees: degrees,
                minutes: minutes,
                seconds: seconds.toFixed(1),
                direction: direction,
                formatted: `${degrees}°${minutes}'${seconds.toFixed(1)}"${direction}`
            };
        }
        
        // 格式化GPS坐标为DMS格式（带多语言标签）
        function formatGpsCoordinates(latitude, longitude, lang = 'zh') {
            const latDMS = decimalToDMS(latitude, true);
            const lonDMS = decimalToDMS(longitude, false);
            
            const labels = {
                zh: {
                    latitude: '纬度',
                    longitude: '经度'
                },
                en: {
                    latitude: 'Latitude',
                    longitude: 'Longitude'
                },
                ru: {
                    latitude: 'Широта',
                    longitude: 'Долгота'
                }
            };
            
            const label = labels[lang] || labels['zh'];
            
            return `${label.latitude}: ${latDMS.formatted}\n${label.longitude}: ${lonDMS.formatted}`;
        }

        // 检查节点是否应该显示（与管理端逻辑完全一致）
        function shouldShowNode(node) {
            // 优先检查自定义显示状态（如果设置了 is_visible，则直接使用）
            // 这是管理端设置的显示/隐藏状态，司机端必须遵循
            if (node.hasOwnProperty('is_visible')) {
                return node.is_visible !== false; // false 表示隐藏，其他都表示显示
            }
            
            // 如果没有edges数据，显示所有节点（向后兼容）
            if (!edges || edges.length === 0) {
                return true;
            }
            
            // 查找与该节点连接的所有道路
            const connectedEdges = edges.filter(edge => 
                edge.start_node === node.id || edge.end_node === node.id
            );
            
            // 如果节点没有连接任何道路，默认显示（可能是特殊节点，如入口）
            if (connectedEdges.length === 0) {
                return true;
            }
            
            // 检查是否所有连接的道路都有road_type字段
            // 如果没有road_type字段，说明可能是旧数据或手动创建的，默认显示所有节点
            const allEdgesHaveRoadType = connectedEdges.every(edge => edge.hasOwnProperty('road_type'));
            if (!allEdgesHaveRoadType) {
                // 向后兼容：如果部分道路没有road_type，显示所有节点
                return true;
            }
            
            // 检查是否至少有一条主路（road_type === 'main'）
            const hasMainRoad = connectedEdges.some(edge => edge.road_type === 'main');
            
            // 与管理端保持一致：只显示连接了主路的节点
            // 不显示只连接支路的节点（支路与支路相交的节点）
            return hasMainRoad;
        }

        // 渲染地图
        function renderMap() {
            const mapWrapper = document.getElementById('map-wrapper');
            const map = document.getElementById('map');
            if (!mapWrapper || !map) return;

            if (nodes.length === 0 && edges.length === 0) {
                map.innerHTML = '<div class="loading">' + i18n[currentLang].loading_map + '</div>';
                return;
            }

            map.innerHTML = '';

            // 计算地图边界（包括节点、车辆和司机位置）
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            nodes.forEach(node => {
                // 只计算应该显示的节点的边界
                if (shouldShowNode(node)) {
                    minX = Math.min(minX, node.x);
                    minY = Math.min(minY, node.y);
                    maxX = Math.max(maxX, node.x);
                    maxY = Math.max(maxY, node.y);
                }
            });
            
            // 包括车辆位置
            if (myVehicle && myVehicle.current_position) {
                const vehicleX = myVehicle.current_position.x;
                const vehicleY = myVehicle.current_position.y;
                minX = Math.min(minX, vehicleX);
                minY = Math.min(minY, vehicleY);
                maxX = Math.max(maxX, vehicleX);
                maxY = Math.max(maxY, vehicleY);
            }
            
            // 包括司机GPS位置（如果有）
            if (currentDriverLocation && currentDriverLocation.latitude && currentDriverLocation.longitude) {
                const driverMapCoords = gpsToMapCoordinates(
                    currentDriverLocation.latitude,
                    currentDriverLocation.longitude,
                    nodes
                );
                if (driverMapCoords) {
                    minX = Math.min(minX, driverMapCoords.x);
                    minY = Math.min(minY, driverMapCoords.y);
                    maxX = Math.max(maxX, driverMapCoords.x);
                    maxY = Math.max(maxY, driverMapCoords.y);
                }
            }

            // 设置地图尺寸（添加边距，左侧padding更大以显示司机位置）
            const leftPadding = 150; // 左侧padding增加，确保司机位置可见
            const rightPadding = 50;
            const topPadding = 50;
            const bottomPadding = 50;
            const padding = 50; // 保持向后兼容，用于元素位置计算
            const mapWidth = Math.max(600, maxX - minX + leftPadding + rightPadding);
            const mapHeight = Math.max(400, maxY - minY + topPadding + bottomPadding);
            
            // 计算偏移量（所有元素需要左移leftPadding-padding的距离）
            const xOffset = leftPadding - padding;
            map.style.width = mapWidth + 'px';
            map.style.height = mapHeight + 'px';

            // 渲染道路
            edges.forEach(edge => {
                const startNode = nodes.find(n => n.id === edge.start_node);
                const endNode = nodes.find(n => n.id === edge.end_node);

                if (startNode && endNode) {
                    const dx = endNode.x - startNode.x;
                    const dy = endNode.y - startNode.y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;

                    const edgeEl = document.createElement('div');
                    edgeEl.className = 'map-edge';
                    edgeEl.style.width = length + 'px';
                    edgeEl.style.left = (startNode.x + padding + xOffset) + 'px';
                    edgeEl.style.top = (startNode.y + padding) + 'px';
                    edgeEl.style.transform = `rotate(${angle}deg)`;

                    // 获取道路状态（优先使用edge_status）
                    const edgeStatus = monitorData.edge_status && monitorData.edge_status[edge.id] || 'normal';
                    const congestion = monitorData.edge_congestion && monitorData.edge_congestion[edge.id];
                    const available = monitorData.edge_available && monitorData.edge_available[edge.id] !== undefined 
                        ? monitorData.edge_available[edge.id] 
                        : edge.is_available;
                    
                    // 根据道路状态设置样式（优先级：封闭 > 占道施工 > 拥堵 > 单向 > 正常）
                    if (!available || edgeStatus === 'closed') {
                        edgeEl.classList.add('closed');
                    } else if (edgeStatus === 'construction') {
                        edgeEl.classList.add('construction');
                    } else if (edgeStatus === 'congested' || congestion > 2.0 || edge.congestion_coeff > 2.0) {
                        edgeEl.classList.add('congested');
                    }
                    
                    // 如果是单向道路，添加特殊样式
                    if (edge.direction && edge.direction !== 'two-way') {
                        edgeEl.classList.add('one-way');
                    }
                    
                    map.appendChild(edgeEl);
                    
                    // 添加道路编号标签
                    const midX = startNode.x + dx * 0.5;
                    const midY = startNode.y + dy * 0.5;
                    const labelEl = document.createElement('div');
                    labelEl.className = 'map-edge-label';
                    labelEl.textContent = edge.name || edge.id;
                    labelEl.style.left = (midX + padding + xOffset - 15) + 'px';
                    labelEl.style.top = (midY + padding - 8) + 'px';
                    labelEl.style.transform = `rotate(${angle}deg)`;
                    labelEl.style.transformOrigin = 'center';
                    
                    // 应用自定义格式
                    if (edge.label_font_size) {
                        labelEl.style.fontSize = `${edge.label_font_size}px`;
                    }
                    if (edge.label_font_family) {
                        labelEl.style.fontFamily = edge.label_font_family;
                    }
                    if (edge.label_font_weight) {
                        labelEl.style.fontWeight = edge.label_font_weight;
                    }
                    if (edge.label_color) {
                        labelEl.style.color = edge.label_color;
                    }
                    if (edge.label_background_color) {
                        labelEl.style.backgroundColor = edge.label_background_color;
                    }
                    if (edge.label_border_color) {
                        labelEl.style.borderColor = edge.label_border_color;
                    }
                    if (edge.label_border_width !== undefined) {
                        labelEl.style.borderWidth = `${edge.label_border_width}px`;
                        labelEl.style.borderStyle = edge.label_border_width > 0 ? 'solid' : 'none';
                    }
                    if (edge.label_border_radius !== undefined) {
                        labelEl.style.borderRadius = `${edge.label_border_radius}px`;
                    }
                    if (edge.label_padding !== undefined) {
                        labelEl.style.padding = `${edge.label_padding}px`;
                    }
                    
                    // 构建道路标签的提示信息
                    let edgeTitle = `道路名称: ${edge.name || edge.id}`;
                    if (edge.id !== (edge.name || edge.id)) {
                        edgeTitle += ` (编号: ${edge.id})`;
                    }
                    if (edge.direction && edge.direction !== 'two-way') {
                        edgeTitle += ' (单向)';
                    }
                    const statusNames = {
                        'normal': '正常',
                        'congested': '拥堵',
                        'construction': '占道施工',
                        'closed': '封闭'
                    };
                    if (edgeStatus !== 'normal') {
                        edgeTitle += ` | 状态: ${statusNames[edgeStatus] || edgeStatus}`;
                    }
                    labelEl.title = edgeTitle;
                    map.appendChild(labelEl);
                    
                    // 如果是单向道路，添加方向箭头
                    if (edge.direction && edge.direction !== 'two-way') {
                        const arrowEl = document.createElement('div');
                        arrowEl.className = 'map-arrow';
                        arrowEl.style.left = (midX + padding + xOffset) + 'px';
                        arrowEl.style.top = (midY + padding) + 'px';
                        
                        // 根据方向属性计算旋转角度，而不是使用几何角度
                        // SVG箭头默认指向上方（north），需要根据实际方向旋转
                        // 上北下南左西右东：north=0°, east=90°, south=180°, west=-90°(270°)
                        let rotation = 0;
                        switch (edge.direction) {
                            case 'north': rotation = 0; break;      // 向上，不需要旋转
                            case 'south': rotation = 180; break;    // 向下，旋转180度
                            case 'east': rotation = 90; break;      // 向右，顺时针90度
                            case 'west': rotation = -90; break;     // 向左，逆时针90度（或270度）
                            case 'northeast': rotation = 45; break;      // 右上，旋转45度
                            case 'northwest': rotation = -45; break;     // 左上，旋转-45度
                            case 'southeast': rotation = 135; break;    // 右下，旋转135度
                            case 'southwest': rotation = -135; break;    // 左下，旋转-135度（或225度）
                            default: 
                                // 如果没有明确的方向属性，使用几何角度作为后备
                                rotation = angle;
                        }
                        
                        arrowEl.style.transform = `rotate(${rotation}deg) translate(-50%, -50%)`;
                        arrowEl.style.transformOrigin = 'center center';
                        arrowEl.title = `单向通行: ${edge.direction}`;
                        map.appendChild(arrowEl);
                    }
                }
            });

            // 渲染地图文字框
            const existingLabels = mapWrapper.querySelectorAll('.map-text-label');
            existingLabels.forEach(el => el.remove());
            
            mapTextLabels.forEach(label => {
                const labelEl = document.createElement('div');
                labelEl.className = 'map-text-label';
                labelEl.setAttribute('data-label-id', label.id);
                labelEl.textContent = label.text;
                labelEl.style.position = 'absolute';
                labelEl.style.left = `${label.x + padding + xOffset}px`;
                labelEl.style.top = `${label.y + padding}px`;
                labelEl.style.fontSize = `${label.font_size || 14}px`;
                labelEl.style.fontFamily = label.font_family || 'Arial';
                labelEl.style.fontWeight = label.font_weight || 'normal';
                labelEl.style.color = label.color || '#000000';
                labelEl.style.backgroundColor = label.background_color || 'transparent';
                labelEl.style.borderColor = label.border_color || 'transparent';
                labelEl.style.borderWidth = `${label.border_width || 0}px`;
                labelEl.style.borderStyle = 'solid';
                labelEl.style.borderRadius = `${label.border_radius || 0}px`;
                labelEl.style.padding = `${label.padding || 4}px`;
                labelEl.style.opacity = label.opacity !== undefined ? label.opacity : 1.0;
                labelEl.style.transform = `rotate(${label.rotation || 0}deg)`;
                labelEl.style.zIndex = label.z_index || 1;
                labelEl.style.userSelect = 'none';
                labelEl.style.pointerEvents = 'none';  // 司机端不可交互
                
                map.appendChild(labelEl);
            });

            // 渲染实际车辆行驶路径和车辆位置（如果已提交车辆）
            if (myVehicle) {
                // 调试信息
                console.log('🚗 [司机端] 渲染车辆信息:', {
                    id: myVehicle.id,
                    status: myVehicle.status,
                    hasCurrentPath: !!myVehicle.current_path,
                    currentPathLength: myVehicle.current_path?.length || 0,
                    hasCurrentPosition: !!myVehicle.current_position,
                    currentPosition: myVehicle.current_position,
                    progress: myVehicle.progress
                });
                
                // 渲染行驶路径（如果有路径）
                if (myVehicle.current_path && myVehicle.current_path.length > 0) {
                    const progress = myVehicle.progress || 0;
                    
                    // 从第二条边开始渲染（第一条边是当前正在行驶的，根据progress决定是否显示）
                    const startIndex = progress > 0.8 ? 1 : 0; // 如果进度超过80%，不显示当前边
                    
                    for (let i = startIndex; i < myVehicle.current_path.length; i++) {
                        const edge = myVehicle.current_path[i];
                        const startNode = nodes.find(n => n.id === edge.start_node);
                        const endNode = nodes.find(n => n.id === edge.end_node);

                        if (startNode && endNode) {
                            const dx = endNode.x - startNode.x;
                            const dy = endNode.y - startNode.y;
                            const length = Math.sqrt(dx * dx + dy * dy);
                            const angle = Math.atan2(dy, dx) * 180 / Math.PI;

                            const routeEl = document.createElement('div');
                            routeEl.className = 'map-route';
                            
                            // 如果是当前正在行驶的第一条边，根据progress只显示剩余部分
                            if (i === 0 && progress > 0 && progress < 1.0) {
                                // 只显示剩余部分
                                const remainingLength = length * (1 - progress);
                                routeEl.style.width = remainingLength + 'px';
                                // 调整起点位置，从当前位置开始
                                const currentX = startNode.x + dx * progress;
                                const currentY = startNode.y + dy * progress;
                                routeEl.style.left = (currentX + padding + xOffset) + 'px';
                                routeEl.style.top = (currentY + padding) + 'px';
                            } else {
                                // 正常显示整条边
                                routeEl.style.width = length + 'px';
                                routeEl.style.left = (startNode.x + padding + xOffset) + 'px';
                                routeEl.style.top = (startNode.y + padding) + 'px';
                            }
                            
                            routeEl.style.transform = `rotate(${angle}deg)`;
                            routeEl.style.transformOrigin = '0 50%';

                            map.appendChild(routeEl);
                        }
                    }
                }
                
                // 渲染车辆位置标记（只要有位置信息就显示，不依赖路径）
                if (myVehicle.current_position && 
                    myVehicle.current_position.x !== undefined && 
                    myVehicle.current_position.y !== undefined &&
                    !isNaN(myVehicle.current_position.x) &&
                    !isNaN(myVehicle.current_position.y)) {
                    
                    const vehicleX = myVehicle.current_position.x;
                    const vehicleY = myVehicle.current_position.y;
                    const progress = myVehicle.progress || 0;
                    
                    // 判断当前模式（GPS模式或自动模式）
                    const isGpsMode = isLocationTracking && currentDriverLocation !== null;
                    const markerColor = isGpsMode ? '#27ae60' : '#e74c3c'; // GPS模式用绿色，自动模式用红色
                    const markerLabel = isGpsMode ? 'GPS' : '车辆';
                    
                    console.log(`✅ [司机端] 渲染车辆位置标记: (${vehicleX.toFixed(2)}, ${vehicleY.toFixed(2)}), 进度: ${(progress * 100).toFixed(1)}%, 模式: ${isGpsMode ? 'GPS定位' : '自动行驶'}`);
                    
                    // 创建车辆标记
                    const vehicleMarker = document.createElement('div');
                    vehicleMarker.className = 'driver-vehicle-marker';
                    vehicleMarker.setAttribute('data-vehicle-id', myVehicle.id);
                    vehicleMarker.style.cssText = `
                        position: absolute;
                        left: ${vehicleX + padding + xOffset}px;
                        top: ${vehicleY + padding}px;
                        width: 24px;
                        height: 24px;
                        border-radius: 50%;
                        background: ${markerColor};
                        border: 3px solid white;
                        box-shadow: 0 0 10px rgba(${isGpsMode ? '39,174,96' : '231,76,60'},0.8), 0 0 20px rgba(${isGpsMode ? '39,174,96' : '231,76,60'},0.4);
                        transform: translate(-50%, -50%);
                        z-index: 50;
                        pointer-events: auto;
                        cursor: pointer;
                        animation: vehiclePulse 2s infinite;
                    `;
                    
                    // 添加模式标识（小图标）
                    const modeIcon = document.createElement('div');
                    modeIcon.style.cssText = `
                        position: absolute;
                        left: 50%;
                        top: 50%;
                        transform: translate(-50%, -50%);
                        font-size: 12px;
                        color: white;
                        font-weight: bold;
                        text-shadow: 0 0 2px rgba(0,0,0,0.5);
                        pointer-events: none;
                    `;
                    modeIcon.textContent = isGpsMode ? '📍' : '🚗';
                    vehicleMarker.appendChild(modeIcon);
                    
                    // 添加脉冲动画
                    if (!document.getElementById('vehicle-pulse-animation')) {
                        const style = document.createElement('style');
                        style.id = 'vehicle-pulse-animation';
                        style.textContent = `
                            @keyframes vehiclePulse {
                                0%, 100% {
                                    transform: translate(-50%, -50%) scale(1);
                                    opacity: 1;
                                }
                                50% {
                                    transform: translate(-50%, -50%) scale(1.2);
                                    opacity: 0.8;
                                }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                    
                    // 添加工具提示
                    const statusText = myVehicle.status === 'moving' ? '行驶中' : 
                                     myVehicle.status === 'arrived' ? '已到达' : 
                                     myVehicle.status || '未知';
                    const progressText = progress > 0 ? `进度: ${(progress * 100).toFixed(1)}%` : '';
                    const modeInfo = isGpsMode ? '\n模式: GPS定位模式' : '\n模式: 自动行驶模式';
                    vehicleMarker.title = `${markerLabel}位置 (${myVehicle.id})\n状态: ${statusText}\n${progressText}${modeInfo}\n坐标: (${vehicleX.toFixed(1)}, ${vehicleY.toFixed(1)})`;
                    
                    // 点击车辆标记显示详细信息
                    vehicleMarker.addEventListener('click', () => {
                        renderActiveVehicleSummary();
                        // 滚动到车辆信息区域
                        const summaryDiv = document.getElementById('active-vehicle-summary');
                        if (summaryDiv) {
                            summaryDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        }
                    });
                    
                    map.appendChild(vehicleMarker);
                    console.log(`✅ [司机端] 车辆位置标记已添加到地图: (${vehicleX.toFixed(2)}, ${vehicleY.toFixed(2)}), 模式: ${isGpsMode ? 'GPS' : '自动'}`);
                } else {
                    console.warn('⚠️ [司机端] 车辆位置信息无效，无法渲染标记:', {
                        hasCurrentPosition: !!myVehicle.current_position,
                        currentPosition: myVehicle.current_position,
                        x: myVehicle.current_position?.x,
                        y: myVehicle.current_position?.y,
                        xType: typeof myVehicle.current_position?.x,
                        yType: typeof myVehicle.current_position?.y,
                        xIsNaN: isNaN(myVehicle.current_position?.x),
                        yIsNaN: isNaN(myVehicle.current_position?.y)
                    });
                }
            } else if (currentRoute && currentRoute.path_edges) {
                // 如果还没有提交车辆，显示规划的路线
                const pathEdges = Array.isArray(currentRoute.path_edges) ? currentRoute.path_edges : [];
                if (pathEdges.length === 0) {
                    logWarn('currentRoute.path_edges 为空或不是数组', currentRoute);
                }
                
                pathEdges.forEach((edge, index) => {
                    // 支持多种边数据格式
                    const startNodeId = edge.start_node || edge.startNode || (edge.length > 0 ? edge[0] : null);
                    const endNodeId = edge.end_node || edge.endNode || (edge.length > 1 ? edge[1] : null);
                    
                    if (!startNodeId || !endNodeId) {
                        logWarn(`路线边 ${index} 缺少节点信息:`, edge);
                        return;
                    }
                    
                    const startNode = nodes.find(n => n.id === startNodeId);
                    const endNode = nodes.find(n => n.id === endNodeId);

                    if (startNode && endNode) {
                        const dx = endNode.x - startNode.x;
                        const dy = endNode.y - startNode.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx) * 180 / Math.PI;

                        const routeEl = document.createElement('div');
                        routeEl.className = 'map-route';
                        routeEl.style.width = length + 'px';
                        routeEl.style.left = (startNode.x + padding + xOffset) + 'px';
                        routeEl.style.top = (startNode.y + padding) + 'px';
                        routeEl.style.transform = `rotate(${angle}deg)`;
                        routeEl.style.transformOrigin = '0 50%';

                        map.appendChild(routeEl);
                    } else {
                        logWarn(`无法找到节点: start=${startNodeId}, end=${endNodeId}`, { startNode, endNode, nodesCount: nodes.length });
                    }
                });
            }

            // 渲染节点（使用与管理端相同的显示逻辑）
            nodes.forEach(node => {
                // 使用 shouldShowNode 函数检查节点是否应该显示
                // 该函数会检查自定义显示状态和道路类型过滤
                if (!shouldShowNode(node)) {
                    return; // 不显示的节点不渲染
                }
                
                const nodeEl = document.createElement('div');
                nodeEl.className = `map-node ${node.type}`;
                nodeEl.style.left = (node.x + padding + xOffset) + 'px';
                nodeEl.style.top = (node.y + padding) + 'px';
                
                // 获取节点拥堵状态
                const nodeCongestion = monitorData.node_congestion && monitorData.node_congestion[node.id] || 0;
                let titleText = `${node.name} (${node.id})`;
                
                if (nodeCongestion > 0) {
                    const congestionNames = {1: '轻微拥堵', 2: '中度拥堵', 3: '严重拥堵'};
                    titleText += ` - ${congestionNames[nodeCongestion] || '拥堵'}`;
                    // 根据拥堵级别添加视觉标识
                    if (nodeCongestion === 3) {
                        nodeEl.style.boxShadow = '0 0 10px rgba(231,76,60,0.8), 0 0 20px rgba(231,76,60,0.4)';
                        nodeEl.style.border = '2px solid #e74c3c';
                    } else if (nodeCongestion === 2) {
                        nodeEl.style.boxShadow = '0 0 8px rgba(230,126,34,0.6)';
                        nodeEl.style.border = '2px solid #e67e22';
                    } else if (nodeCongestion === 1) {
                        nodeEl.style.boxShadow = '0 0 6px rgba(243,156,18,0.5)';
                        nodeEl.style.border = '2px solid #f39c12';
                    }
                }
                nodeEl.title = titleText;

                // 如果是起点或终点，高亮显示（但不要覆盖拥堵标识）
                if (currentRoute && nodeCongestion === 0) {
                    if (node.id === currentRoute.start_node) {
                        nodeEl.style.boxShadow = '0 0 10px rgba(46, 204, 113, 0.8)';
                        nodeEl.style.border = '2px solid #2ecc71';
                    }
                    if (node.id === currentRoute.target_node) {
                        nodeEl.style.boxShadow = '0 0 10px rgba(231, 76, 60, 0.8)';
                        nodeEl.style.border = '2px solid #e74c3c';
                    }
                }

                // 在圆形节点内部显示节点编号（只显示数字，去除"节点"前缀）
                const nodeNumber = node.name || node.id;
                if (nodeNumber) {
                    // 提取纯数字部分，去除"节点"等文字前缀
                    let displayNumber = String(nodeNumber);
                    // 移除"节点"前缀（如果存在）
                    displayNumber = displayNumber.replace(/^节点\s*/i, '').trim();
                    // 如果去除前缀后为空，或者需要进一步提取数字
                    // 尝试提取所有数字
                    const numberMatch = displayNumber.match(/\d+/);
                    if (numberMatch) {
                        displayNumber = numberMatch[0];
                }
                    
                    // 创建文字元素
                    const numberSpan = document.createElement('span');
                    numberSpan.className = 'node-number';
                    numberSpan.textContent = displayNumber;
                    nodeEl.appendChild(numberSpan);
                }

                // 添加点击节点选择终点的功能
                nodeEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const targetSelect = document.getElementById('target-node');
                    if (targetSelect) {
                        // 设置终点选择框的值
                        targetSelect.value = node.id;
                        // 触发change事件，确保相关逻辑更新
                        targetSelect.dispatchEvent(new Event('change'));
                        // 显示提示
                        showAlert('success', `已选择终点: ${node.name || node.id}`);
                    }
                });
                
                // 添加鼠标悬停提示
                nodeEl.style.cursor = 'pointer';
                nodeEl.title = titleText + ' (点击选择为终点)';

                map.appendChild(nodeEl);
            });
            
            // 渲染司机当前位置（如果有，始终显示，不管是否在节点上）
            if (currentDriverLocation && currentDriverLocation.latitude !== null && currentDriverLocation.longitude !== null) {
                console.log('📍 [renderMap] 开始渲染司机位置标记, GPS坐标:', currentDriverLocation.latitude, currentDriverLocation.longitude);
                
                // 将GPS坐标转换为地图坐标
                let mapCoords = gpsToMapCoordinates(
                    currentDriverLocation.latitude,
                    currentDriverLocation.longitude,
                    nodes
                );
                
                console.log('📍 [renderMap] GPS坐标转换结果:', mapCoords);
                
                // 如果GPS坐标转换失败，使用最近的节点作为参考位置（仍然显示司机位置）
                if (!mapCoords) {
                    const nodesWithGps = nodes.filter(n => 
                        n.latitude !== null && 
                        n.latitude !== undefined && 
                        n.longitude !== null && 
                        n.longitude !== undefined
                    );
                    
                    if (nodesWithGps.length > 0) {
                        // 找到最近的节点
                        let minDistance = Infinity;
                        let nearestNode = null;
                        
                        nodesWithGps.forEach(node => {
                            const distance = calculateGpsDistance(
                                currentDriverLocation.latitude,
                                currentDriverLocation.longitude,
                                parseFloat(node.latitude),
                                parseFloat(node.longitude)
                            );
                            
                            if (distance < minDistance) {
                                minDistance = distance;
                                nearestNode = node;
                            }
                        });
                        
                        if (nearestNode) {
                            // 使用最近节点的地图坐标作为参考位置
                            mapCoords = { x: nearestNode.x, y: nearestNode.y };
                        }
                    }
                }
                
                if (mapCoords) {
                    // 清除旧的司机位置标记（如果存在）
                    const oldMarker = map.querySelector('.driver-location-marker');
                    if (oldMarker) {
                        oldMarker.remove();
                    }
                    
                    // 创建司机位置标记
                    const driverMarker = document.createElement('div');
                    driverMarker.className = 'driver-location-marker';
                    const markerLeft = mapCoords.x + padding + xOffset;
                    const markerTop = mapCoords.y + padding;
                    driverMarker.style.cssText = `
                        position: absolute;
                        left: ${markerLeft}px;
                        top: ${markerTop}px;
                        width: 20px;
                        height: 20px;
                        border-radius: 50%;
                        background: #ff0000;
                        border: 3px solid white;
                        box-shadow: 0 0 10px rgba(255,0,0,0.8), 0 0 20px rgba(255,0,0,0.4);
                        transform: translate(-50%, -50%);
                        z-index: 100;
                        cursor: pointer;
                    `;
                    
                    console.log('📍 [renderMap] 司机位置标记样式已设置:', {
                        left: markerLeft.toFixed(2),
                        top: markerTop.toFixed(2),
                        mapCoords: { x: mapCoords.x.toFixed(2), y: mapCoords.y.toFixed(2) },
                        padding: padding,
                        xOffset: xOffset
                    });
                    
                    // 创建脉冲动画
                    const pulse = document.createElement('div');
                    pulse.style.cssText = `
                        position: absolute;
                        left: 50%;
                        top: 50%;
                        width: 100%;
                        height: 100%;
                        border-radius: 50%;
                        background: rgba(255,0,0,0.3);
                        transform: translate(-50%, -50%);
                        animation: pulse 2s infinite;
                    `;
                    driverMarker.appendChild(pulse);
                    
                    // 添加距离信息到tooltip
                    const nodesWithGps = nodes.filter(n => 
                        n.latitude !== null && 
                        n.latitude !== undefined && 
                        n.longitude !== null && 
                        n.longitude !== undefined
                    );
                    
                    // 使用DMS格式显示GPS坐标（多语言）
                    let tooltipText = i18n[currentLang].my_location || '我的位置';
                    tooltipText += '\n' + formatGpsCoordinates(
                        currentDriverLocation.latitude,
                        currentDriverLocation.longitude,
                        currentLang
                    );
                    if (currentDriverLocation.accuracy) {
                        const accuracyLabel = i18n[currentLang].location_accuracy || '精度';
                        const metersLabel = i18n[currentLang].meters || '米';
                        const accuracy = currentDriverLocation.accuracy;
                        tooltipText += `\n${accuracyLabel}: ±${accuracy.toFixed(0)}${metersLabel}`;
                        
                        // 根据精度推断定位方式并给出提示
                        if (accuracy > 100) {
                            tooltipText += '\n⚠️ 可能是WiFi定位，精度较低';
                            tooltipText += '\n💡 建议在室外使用以获得GPS定位';
                        } else if (accuracy > 20) {
                            tooltipText += '\n📍 可能是混合定位（GPS+WiFi）';
                        } else {
                            tooltipText += '\n✅ GPS定位，精度良好';
                        }
                    } else {
                        tooltipText += '\n⚠️ 精度信息不可用';
                    }
                    
                    if (nodesWithGps.length > 0) {
                        // 计算到最近的GPS节点的距离
                        const distances = nodesWithGps.map(node => {
                            const dist = calculateGpsDistance(
                                currentDriverLocation.latitude,
                                currentDriverLocation.longitude,
                                parseFloat(node.latitude),
                                parseFloat(node.longitude)
                            );
                            return { node, distance: dist };
                        });
                        distances.sort((a, b) => a.distance - b.distance);
                        
                        if (distances.length > 0) {
                            const nearest = distances[0];
                            const nearestNodeLabel = i18n[currentLang].nearest_node || '最近节点';
                            const distanceLabel = i18n[currentLang].distance || '距离';
                            const metersLabel = i18n[currentLang].meters || '米';
                            tooltipText += `\n\n${nearestNodeLabel}: ${nearest.node.name || nearest.node.id}`;
                            tooltipText += `\n${distanceLabel}: ${nearest.distance.toFixed(0)}${metersLabel}`;
                            
                            // 显示到前3个节点的距离
                            if (distances.length > 1) {
                                const nearbyNodesLabel = i18n[currentLang].nearby_nodes || '附近节点';
                                tooltipText += `\n\n${nearbyNodesLabel}:`;
                                distances.slice(0, Math.min(3, distances.length)).forEach((item, idx) => {
                                    if (idx > 0) {
                                        tooltipText += `\n${item.node.name || item.node.id}: ${item.distance.toFixed(0)}${metersLabel}`;
                                    }
                                });
                            }
                        }
                    }
                    
                    driverMarker.title = tooltipText;
                    map.appendChild(driverMarker);
                    console.log('📍 [renderMap] 司机位置标记已添加到地图, 地图坐标:', mapCoords.x.toFixed(2), mapCoords.y.toFixed(2));
                } else {
                    console.warn('⚠️ [renderMap] 司机位置标记未添加: mapCoords为空');
                }
            } else {
                console.log('📍 [renderMap] 未渲染司机位置: currentDriverLocation为空或GPS坐标无效');
            }
            
            // 应用地图旋转（在渲染完成后）
            applyMapRotation(mapRotation);
            
            // 首次渲染时，自动调整视图让地图全部显示（仅在首次渲染时执行）
            if (!window.mapInitialViewAdjusted && nodes.length > 0) {
                setTimeout(() => {
                    fitMapToView();
                    window.mapInitialViewAdjusted = true;
                }, 100);
            }
        }
        
        // 自动调整地图视图，让地图全部显示在视口中
        function fitMapToView() {
            const mapWrapper = document.getElementById('map-wrapper');
            const map = document.getElementById('map');
            if (!mapWrapper || !map) return;
            
            // 等待地图渲染完成
            setTimeout(() => {
                // 获取地图的实际尺寸（考虑padding）
                const mapWidth = parseFloat(map.style.width) || map.offsetWidth || map.clientWidth;
                const mapHeight = parseFloat(map.style.height) || map.offsetHeight || map.clientHeight;
                
                // 获取容器的尺寸
                const containerWidth = mapWrapper.clientWidth;
                const containerHeight = mapWrapper.clientHeight;
                
                if (mapWidth <= 0 || mapHeight <= 0 || containerWidth <= 0 || containerHeight <= 0) {
                    console.warn('地图尺寸无效，跳过自动调整:', { mapWidth, mapHeight, containerWidth, containerHeight });
                    return; // 尺寸无效，跳过
                }
                
                // 计算合适的缩放比例，让地图完全显示在容器中（留出一些边距）
                const scaleX = (containerWidth * 0.95) / mapWidth; // 95%宽度
                const scaleY = (containerHeight * 0.95) / mapHeight; // 95%高度
                const targetScale = Math.min(scaleX, scaleY); // 选择较小的缩放比例，确保地图完全显示
                
                // 应用缩放（限制在合理范围内，但优先使用计算出的值）
                mapScale = Math.max(0.1, Math.min(3.0, targetScale));
                
                // 如果计算出的缩放比例大于0.5，则使用0.5（默认50%）
                if (mapScale > 0.5) {
                    mapScale = 0.5;
                }
                
                // 计算平移，使地图居中
                const scaledWidth = mapWidth * mapScale;
                const scaledHeight = mapHeight * mapScale;
                mapTranslateX = (containerWidth - scaledWidth) / 2;
                mapTranslateY = (containerHeight - scaledHeight) / 2;
                
                // 更新地图变换
                updateMapTransform();
                
                // 更新缩放显示
                const zoomLevelEl = document.getElementById('zoom-level');
                if (zoomLevelEl) {
                    zoomLevelEl.textContent = Math.round(mapScale * 100) + '%';
                }
                
                console.log('地图视图已自动调整:', {
                    mapSize: { width: mapWidth, height: mapHeight },
                    containerSize: { width: containerWidth, height: containerHeight },
                    scale: mapScale,
                    translate: { x: mapTranslateX, y: mapTranslateY }
                });
            }, 200); // 延迟200ms确保地图已完全渲染
        }

        // 更新道路状态
        function updateRoadStatus() {
            const statusDiv = document.getElementById('road-status');
            const contentDiv = document.getElementById('status-content');

            if (!monitorData.edge_congestion && edges.length === 0) {
                statusDiv.style.display = 'none';
                return;
            }

            const congested = [];
            const closed = [];
            const oneWay = [];
            const construction = [];
            const nodeCongested = [];

            // 从edges数据中获取单向道路信息
            edges.forEach(edge => {
                if (edge.direction && edge.direction !== 'two-way') {
                    oneWay.push(edge.id);
                }
            });

            // 从监控数据中获取道路状态
            if (monitorData.edge_status) {
                Object.keys(monitorData.edge_status).forEach(edgeId => {
                    const status = monitorData.edge_status[edgeId];
                    if (status === 'construction') {
                        construction.push(edgeId);
                    } else if (status === 'closed') {
                        closed.push(edgeId);
                    } else if (status === 'congested') {
                        congested.push(edgeId);
                    }
                });
            }

            // 从监控数据中获取拥堵和封闭道路（兼容旧数据）
            if (monitorData.edge_congestion) {
                Object.keys(monitorData.edge_congestion).forEach(edgeId => {
                    const congestion = monitorData.edge_congestion[edgeId];
                    const available = monitorData.edge_available && monitorData.edge_available[edgeId] !== undefined 
                        ? monitorData.edge_available[edgeId] 
                        : true;
                    const edgeStatus = monitorData.edge_status && monitorData.edge_status[edgeId];

                    // 如果已经有明确的状态设置，跳过
                    if (edgeStatus) return;

                    if (!available) {
                        if (!closed.includes(edgeId)) closed.push(edgeId);
                    } else if (congestion > 2.0) {
                        if (!congested.includes(edgeId)) congested.push(edgeId);
                    }
                });
            }

            // 获取节点拥堵信息
            if (monitorData.node_congestion) {
                Object.keys(monitorData.node_congestion).forEach(nodeId => {
                    const congestionLevel = monitorData.node_congestion[nodeId];
                    if (congestionLevel > 0) {
                        const node = nodes.find(n => n.id === nodeId);
                        const congestionNames = {1: '轻微', 2: '中度', 3: '严重'};
                        nodeCongested.push(`${node ? node.name : nodeId}(${congestionNames[congestionLevel] || congestionLevel})`);
                    }
                });
            }

            let html = '';

            if (oneWay.length > 0) {
                html += `
                    <div class="road-status">
                        <div class="status-indicator" style="background: #e67e22;"></div>
                        <div>
                            <strong>${i18n[currentLang].one_way_roads || '单向道路'}:</strong> ${oneWay.join(', ')}
                        </div>
                    </div>
                `;
            }

            if (congested.length > 0) {
                html += `
                    <div class="road-status">
                        <div class="status-indicator status-congested"></div>
                        <div>
                            <strong>${i18n[currentLang].congested_roads}:</strong> ${congested.join(', ')}
                        </div>
                    </div>
                `;
            }

            if (closed.length > 0) {
                html += `
                    <div class="road-status">
                        <div class="status-indicator status-closed"></div>
                        <div>
                            <strong>${i18n[currentLang].closed_roads}:</strong> ${closed.join(', ')}
                        </div>
                    </div>
                `;
            }

            if (construction.length > 0) {
                html += `
                    <div class="road-status">
                        <div class="status-indicator" style="background: #f39c12;"></div>
                        <div>
                            <strong>${i18n[currentLang].construction_roads || '占道施工道路'}:</strong> ${construction.join(', ')}
                        </div>
                    </div>
                `;
            }

            if (nodeCongested.length > 0) {
                html += `
                    <div class="road-status">
                        <div class="status-indicator" style="background: #e67e22;"></div>
                        <div>
                            <strong>${i18n[currentLang].congested_nodes || '拥堵节点'}:</strong> ${nodeCongested.join(', ')}
                        </div>
                    </div>
                `;
            }

            if (html) {
                contentDiv.innerHTML = html;
                statusDiv.style.display = 'block';
            } else {
                html = `
                    <div class="road-status">
                        <div class="status-indicator status-normal"></div>
                        <div>${i18n[currentLang].normal_roads}</div>
                    </div>
                `;
                contentDiv.innerHTML = html;
                statusDiv.style.display = 'block';
            }
        }

        // 获取司机历史
        async function fetchDriverHistory() {
            if (!driverId) return;

            const result = await apiCall(`/drivers/${driverId}`);
            if (result.success && result.routes) {
                driverRoutes = result.routes;
                displayHistory();
            }
        }

        // 显示历史记录
        function displayHistory() {
            const contentDiv = document.getElementById('history-content');

            if (driverRoutes.length === 0) {
                contentDiv.innerHTML = `<div class="loading">${i18n[currentLang].no_history}</div>`;
                return;
            }

            contentDiv.innerHTML = driverRoutes.slice().reverse().map(route => {
                const startNode = nodes.find(n => n.id === route.start_node);
                const targetNode = nodes.find(n => n.id === route.target_node);
                const time = new Date(route.requested_at).toLocaleString();

                return `
                    <div class="history-item">
                        <div><strong>${startNode ? startNode.name : route.start_node}</strong> → <strong>${targetNode ? targetNode.name : route.target_node}</strong></div>
                        <div style="margin-top: 5px; font-size: 12px; color: #666;">
                            ${i18n[currentLang].estimated_time}: ${route.estimated_minutes || 'N/A'} ${i18n[currentLang].minutes} | 
                            ${i18n[currentLang].efficiency_score}: ${route.efficiency_score ? route.efficiency_score.toFixed(2) : 'N/A'}
                        </div>
                        <div class="history-time">${time}</div>
                    </div>
                `;
            }).join('');
        }

        // 显示提示
        function showAlert(type, message) {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            // 支持换行显示
            alertDiv.style.whiteSpace = 'pre-line';
            alertDiv.textContent = message;
            
            const content = document.querySelector('.content');
            if (content) {
                content.insertBefore(alertDiv, content.firstChild);

                setTimeout(() => {
                    if (alertDiv.parentNode) {
                        alertDiv.remove();
                    }
                }, 8000); // 错误信息显示更长时间
            } else {
                // 如果content不存在，使用alert作为备用
                alert(message);
            }
        }

        // 设置事件监听
        function setupEventListeners() {
            // 语言切换
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const lang = btn.getAttribute('data-lang');
                    loadLanguage(lang);
                });
            });

            const speedInput = document.getElementById('vehicle-speed');
            if (speedInput) {
                speedInput.dataset.userModified = speedInput.value ? 'true' : 'false';
                speedInput.addEventListener('input', () => {
                    speedInput.dataset.userModified = speedInput.value ? 'true' : 'false';
                });
            }

            const plannerSelect = document.getElementById('planner-mode');
            if (plannerSelect) {
                plannerSelect.addEventListener('change', togglePlannerModeFields);
                togglePlannerModeFields();
            }

            // 注册司机
            document.getElementById('register-driver').addEventListener('click', registerDriver);
            
            // 可折叠section的标题点击事件
            document.querySelectorAll('.section.collapsible .section-title').forEach(title => {
                title.addEventListener('click', () => {
                    const section = title.closest('.section');
                    if (section) {
                        section.classList.toggle('collapsed');
                    }
                });
            });
            
            // 当司机ID改变时，自动加载司机信息
            const driverIdInput = document.getElementById('driver-id');
            if (driverIdInput) {
                let loadTimeout = null;
                driverIdInput.addEventListener('blur', () => {
                    const driverId = driverIdInput.value.trim();
                    if (driverId) {
                        // 延迟加载，避免频繁请求
                        if (loadTimeout) clearTimeout(loadTimeout);
                        loadTimeout = setTimeout(() => {
                            loadDriverInfo(driverId);
                        }, 500);
                    }
                });
            }

            // 定位按钮已删除（GPS模式自动定位，无需手动按钮）
            
            // 监听运行模式切换（合并所有模式切换逻辑）
            const modeRadios = document.querySelectorAll('.active-mode-radio');
            modeRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    const selectedMode = e.target.value;
                    vehicleMode = selectedMode;
                    console.log(`模式切换为: ${vehicleMode === 'gps' ? 'GPS模式' : '自动模式'}`);
                    
                    // GPS模式下，修改计算路线按钮文本为"提交为实际车辆"
                    const calculateBtn = document.getElementById('calculate-route');
                    if (calculateBtn) {
                        if (selectedMode === 'gps') {
                            calculateBtn.textContent = i18n[currentLang].submit_vehicle || '✅ 提交为实际车辆';
                        } else {
                            calculateBtn.textContent = i18n[currentLang].calculate_route || '🗺️ 计算最优路线';
                        }
                    }
                    
                    // 更新起点选择框
                    if (selectedMode === 'gps' && currentDriverLocation !== null && 
                        currentDriverLocation.latitude !== null && 
                        currentDriverLocation.longitude !== null) {
                        updateStartNodeForGps();
                    } else if (selectedMode === 'auto') {
                        // 切换到自动模式，恢复普通节点选择
                        updateNodeSelects();
                    }
                    
                    // 更新车辆位置跟踪
                    if (vehicleMode === 'gps') {
                        // 切换到GPS模式，自动开始定位
                        if (!isLocationTracking) {
                            // 自动开始GPS定位
                            showAlert('info', 'GPS模式已启用，正在自动获取位置...');
                            getCurrentLocationAndFindNodes();
                        } else if (myVehicle) {
                            // 如果已经在跟踪且有车辆，立即开始更新车辆位置
                            startGpsVehiclePositionUpdate();
                        }
                    } else {
                        // 切换到自动模式，停止GPS位置更新
                        stopGpsVehiclePositionUpdate();
                    }
                });
            });

            // 计算路线
            document.getElementById('calculate-route').addEventListener('click', calculateRoute);
            
            // 提交为实际车辆
            const submitBtn = document.getElementById('submit-vehicle');
            if (submitBtn) {
                submitBtn.addEventListener('click', async () => {
                    await submitVehicle();
                });
            }

            const arriveBtn = document.getElementById('mark-arrived');
            if (arriveBtn) {
                arriveBtn.addEventListener('click', markVehicleArrived);
            }

            // 中断导航按钮
            const cancelNavBtn = document.getElementById('cancel-navigation');
            if (cancelNavBtn) {
                cancelNavBtn.addEventListener('click', cancelNavigation);
            }

            // 地图控制
            const resetBtn = document.getElementById('reset-map-view');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    mapTranslateX = 0;
                    mapTranslateY = 0;
                    updateMapTransform();
                });
            }

            const fullscreenBtn = document.getElementById('toggle-map-fullscreen');
            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', () => {
                    const mapContainer = document.querySelector('.map-container');
                    if (mapContainer) {
                        if (!document.fullscreenElement) {
                            mapContainer.requestFullscreen().catch(err => {
                                logError('无法进入全屏:', err);
                            });
                        } else {
                            document.exitFullscreen();
                        }
                    }
                });
            }
            
            // 标签显示切换（全部 ↔ 仅节点）
            let labelMode = 'all'; // 'all' 或 'nodes-only'
            const toggleLabelsBtn = document.getElementById('toggle-labels');
            if (toggleLabelsBtn) {
                // 初始化按钮状态
                toggleLabelsBtn.setAttribute('data-mode', i18n[currentLang].toggle_labels_all_short || '全部');
                const labelText = toggleLabelsBtn.querySelector('.label-text');
                
                toggleLabelsBtn.addEventListener('click', function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    const map = document.getElementById('map');
                    if (!map) {
                        return;
                    }
                    
                    const texts = i18n[currentLang] || i18n.zh;
                    
                    // 切换模式
                    if (labelMode === 'all') {
                        // 切换到仅节点模式（隐藏道路名称）
                            labelMode = 'nodes-only';
                            map.classList.add('map-labels-nodes-only');
                        const nodesText = texts.toggle_labels_nodes_only_short || '仅节点';
                        this.setAttribute('data-mode', nodesText);
                        if (labelText) labelText.textContent = nodesText;
                        this.title = texts.toggle_labels_nodes_only || '当前: 仅显示节点编号';
                    } else {
                        // 切换到全部显示模式
                            labelMode = 'all';
                        map.classList.remove('map-labels-nodes-only');
                        const allText = texts.toggle_labels_all_short || '全部';
                        this.setAttribute('data-mode', allText);
                        if (labelText) labelText.textContent = allText;
                        this.title = texts.toggle_labels_all || '当前: 全部显示';
                    }
                });
            }

            // 地图缩放和拖拽功能（使用全局变量和函数）
            const mapWrapper = document.getElementById('map-wrapper');
            const mapContainer = document.querySelector('.map-container');
            const zoomLevelEl = document.getElementById('zoom-level');
            
            // 双指缩放相关变量
            let initialDistance = 0;
            let initialScale = 1.0;
            let isPinching = false;
            let pinchCenterX = 0; // 双指中心点的屏幕X坐标
            let pinchCenterY = 0; // 双指中心点的屏幕Y坐标
            let pinchMapX = 0; // 双指中心点对应的地图X坐标（缩放前）
            let pinchMapY = 0; // 双指中心点对应的地图Y坐标（缩放前）
            
            // 拖拽相关变量
            let isDragging = false;
            let dragStartX = 0;
            let dragStartY = 0;
            let dragStartTranslateX = 0;
            let dragStartTranslateY = 0;
            
            // 更新地图缩放（使用全局 mapScale 变量和 updateMapTransform 函数）
            function updateMapScale(scale, centerX = null, centerY = null) {
                const oldScale = mapScale;
                mapScale = Math.max(0.1, Math.min(3.0, scale)); // 限制在 10% 到 300% 之间
                
                // 如果指定了缩放中心点，调整平移使该点保持不变
                if (centerX !== null && centerY !== null) {
                    const mapWrapper = document.getElementById('map-wrapper');
                    if (mapWrapper) {
                        const rect = mapWrapper.getBoundingClientRect();
                        // 将屏幕坐标转换为相对于容器的坐标
                        const relativeX = centerX - rect.left;
                        const relativeY = centerY - rect.top;
                        
                        // 计算缩放前，该屏幕点对应的地图坐标
                        // 地图坐标 = (屏幕坐标 - 平移) / 缩放
                        const mapX = (relativeX - mapTranslateX) / oldScale;
                        const mapY = (relativeY - mapTranslateY) / oldScale;
                        
                        // 缩放后，调整平移使该地图点仍然在相同的屏幕位置
                        // 屏幕坐标 = 平移 + 地图坐标 * 新缩放
                        mapTranslateX = relativeX - mapX * mapScale;
                        mapTranslateY = relativeY - mapY * mapScale;
                    }
                }
                
                updateMapTransform(); // 使用全局的 updateMapTransform 函数
                if (zoomLevelEl) {
                    zoomLevelEl.textContent = Math.round(mapScale * 100) + '%';
                }
            }
            
            // 计算两点之间的距离
            function getDistance(touch1, touch2) {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            // 计算两点的中心点
            function getCenterPoint(touch1, touch2) {
                return {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
            }
            
            // 双指缩放和单指拖拽事件处理（参考高德地图交互）
            if (mapContainer) {
                // 触摸事件处理（支持单指拖拽和双指缩放）
                let touchStartTime = 0;
                let touchMoved = false;
                let lastTouchX = 0;  // 上一次触摸位置
                let lastTouchY = 0;
                let lastPinchDistance = 0;  // 上一次双指距离
                let lastPinchCenterX = 0;   // 上一次双指中心
                let lastPinchCenterY = 0;
                // 保存当前触摸信息，用于在 touchmove 中判断拖动
                let currentTouchInfo = null;
                
                mapContainer.addEventListener('touchstart', (e) => {
                    // 如果点击的是按钮或输入框，不触发拖拽（这些需要完全阻止）
                    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || 
                        e.target.closest('button') || e.target.closest('input')) {
                        return;
                    }
                    
                    // 记录是否触摸到了节点（但不立即返回，允许拖动）
                    const touchedNode = e.target.closest('.map-node');
                    let touchedNodeId = null;
                    if (touchedNode) {
                        touchedNodeId = touchedNode.getAttribute('data-id');
                    }
                    
                    // 记录初始触摸位置，用于判断是点击还是拖动
                    let initialTouchX = 0;
                    let initialTouchY = 0;
                    if (e.touches.length === 1) {
                        initialTouchX = e.touches[0].clientX;
                        initialTouchY = e.touches[0].clientY;
                    }
                    
                    // 保存触摸信息到变量中，供后续 touchmove 使用
                    currentTouchInfo = {
                        touchedNodeId: touchedNodeId,
                        initialTouchX: initialTouchX,
                        initialTouchY: initialTouchY,
                        startTime: Date.now(),
                        isPotentialClick: touchedNode !== null // 如果触摸到节点，可能是点击
                    };
                    
                    // 如果触摸到节点，先不阻止默认行为，让点击事件能够触发
                    // 只有在 touchmove 中检测到拖动时，才阻止默认行为
                    if (!touchedNode) {
                        e.preventDefault(); // 空白区域立即阻止默认行为
                    }
                    touchStartTime = Date.now();
                    touchMoved = false;
                    
                    if (e.touches.length === 2) {
                        // 双指缩放开始
                        isPinching = true;
                        isDragging = false;
                        
                        // 记录初始状态
                        const center = getCenterPoint(e.touches[0], e.touches[1]);
                        lastPinchCenterX = center.x;
                        lastPinchCenterY = center.y;
                        lastPinchDistance = getDistance(e.touches[0], e.touches[1]);
                        initialScale = mapScale;
                        initialDistance = lastPinchDistance;
                        
                        // 记录初始双指中心对应的地图坐标（用于保持缩放中心）
                        // 需要考虑旋转角度
                        const mapWrapper = document.getElementById('map-wrapper');
                        if (mapWrapper) {
                            const rect = mapWrapper.getBoundingClientRect();
                            pinchCenterX = center.x;
                            pinchCenterY = center.y;
                            const relativeX = center.x - rect.left;
                            const relativeY = center.y - rect.top;
                            
                            // 考虑旋转：屏幕坐标转地图坐标
                            // transform顺序是 rotate() translate() scale()
                            // 所以反向计算：1.除以scale 2.减去translate(在旋转坐标系中) 3.反向旋转
                            const rotation = typeof mapRotation !== 'undefined' ? mapRotation : 0;
                            const rad = rotation * Math.PI / 180;
                            
                            // 先计算在旋转坐标系中的位置（减去translate，除以scale）
                            const rotatedX = (relativeX - mapTranslateX) / mapScale;
                            const rotatedY = (relativeY - mapTranslateY) / mapScale;
                            
                            // 反向旋转得到原始地图坐标
                            pinchMapX = rotatedX * Math.cos(rad) + rotatedY * Math.sin(rad);
                            pinchMapY = -rotatedX * Math.sin(rad) + rotatedY * Math.cos(rad);
                        }
                    } else if (e.touches.length === 1 && !isPinching) {
                        // 单指触摸：先不立即开始拖动，等 touchmove 时判断是否真的拖动
                        // 这样可以区分点击和拖动，特别是从节点开始的触摸
                        const touch = e.touches[0];
                        lastTouchX = touch.clientX;
                        lastTouchY = touch.clientY;
                        dragStartX = touch.clientX;
                        dragStartY = touch.clientY;
                        dragStartTranslateX = mapTranslateX;
                        dragStartTranslateY = mapTranslateY;
                        // 不在 touchstart 时立即设置 isDragging = true
                        // 而是等 touchmove 时根据移动距离判断
                    }
                }, { passive: false });
                
                mapContainer.addEventListener('touchmove', (e) => {
                    // 如果之前在 touchstart 时没有 preventDefault（因为触摸到节点），
                    // 现在检测到移动，应该阻止默认行为以支持拖动
                    if (currentTouchInfo && currentTouchInfo.isPotentialClick) {
                        e.preventDefault(); // 开始拖动时阻止默认行为，这会阻止后续的 click 事件
                        currentTouchInfo.isPotentialClick = false; // 标记为拖动，不再是点击
                    } else if (!currentTouchInfo || !currentTouchInfo.isPotentialClick) {
                        e.preventDefault(); // 其他情况正常阻止默认行为
                    }
                    
                    if (e.touches.length === 2) {
                        // 双指操作：缩放 + 平移
                        isPinching = true;
                        touchMoved = true;
                        
                        const center = getCenterPoint(e.touches[0], e.touches[1]);
                        const currentDistance = getDistance(e.touches[0], e.touches[1]);
                        
                        // 计算缩放比例
                        const scaleRatio = currentDistance / initialDistance;
                        const newScale = Math.max(0.1, Math.min(3.0, initialScale * scaleRatio));
                        
                        // 计算双指中心的移动量（用于同时平移）
                        const centerDeltaX = center.x - lastPinchCenterX;
                        const centerDeltaY = center.y - lastPinchCenterY;
                        
                        // 考虑旋转角度
                        const rotation = typeof mapRotation !== 'undefined' ? mapRotation : 0;
                        const rad = rotation * Math.PI / 180;
                        
                        // 将屏幕坐标系的移动转换为旋转后坐标系的移动
                        const adjustedCenterDeltaX = centerDeltaX * Math.cos(rad) + centerDeltaY * Math.sin(rad);
                        const adjustedCenterDeltaY = -centerDeltaX * Math.sin(rad) + centerDeltaY * Math.cos(rad);
                        
                        // 以初始双指中心为基准进行缩放
                        const mapWrapper = document.getElementById('map-wrapper');
                        if (mapWrapper) {
                            const rect = mapWrapper.getBoundingClientRect();
                            // 当前双指中心的屏幕坐标
                            const screenCenterX = center.x - rect.left;
                            const screenCenterY = center.y - rect.top;
                            
                            // 将地图坐标转换回旋转后坐标系
                            // pinchMapX, pinchMapY 是原始地图坐标，需要旋转到当前坐标系
                            const rotatedPinchX = pinchMapX * Math.cos(-rad) + pinchMapY * Math.sin(-rad);
                            const rotatedPinchY = -pinchMapX * Math.sin(-rad) + pinchMapY * Math.cos(-rad);
                            
                            // 计算新的平移值：当前屏幕中心 = translate + 旋转后地图点 * scale
                            // 所以：translate = 屏幕中心 - 旋转后地图点 * scale
                            mapTranslateX = screenCenterX - rotatedPinchX * newScale;
                            mapTranslateY = screenCenterY - rotatedPinchY * newScale;
                            mapScale = newScale;
                            
                            updateMapTransform();
                            if (zoomLevelEl) {
                                zoomLevelEl.textContent = Math.round(mapScale * 100) + '%';
                            }
                        }
                        
                        // 更新上一次位置
                        lastPinchCenterX = center.x;
                        lastPinchCenterY = center.y;
                        lastPinchDistance = currentDistance;
                        
                    } else if (e.touches.length === 1) {
                        const touch = e.touches[0];
                        
                        // 如果之前是潜在的点击（触摸到节点），现在有移动，清除点击标记
                        if (currentTouchInfo && currentTouchInfo.isPotentialClick) {
                            // 计算从初始位置的移动距离
                            let initialX = currentTouchInfo.initialTouchX || touch.clientX;
                            let initialY = currentTouchInfo.initialTouchY || touch.clientY;
                            const dx = touch.clientX - initialX;
                            const dy = touch.clientY - initialY;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            // 只要有移动（即使很小），也清除点击标记
                            if (distance > 1) {
                                currentTouchInfo.isPotentialClick = false;
                                e.preventDefault(); // 确保阻止默认行为以支持拖动
                            }
                        }
                        
<<<<<<< HEAD
                        // 如果还没开始拖动，检查是否应该开始拖动
                        // 这样可以支持从节点开始拖动
                        if (!isDragging && !isPinching) {
                            // 计算从初始位置的移动距离
                            let initialX = touch.clientX;
                            let initialY = touch.clientY;
                            
                            // 从保存的触摸信息中获取初始位置
                            if (currentTouchInfo) {
                                initialX = currentTouchInfo.initialTouchX || initialX;
                                initialY = currentTouchInfo.initialTouchY || initialY;
                            }
                            
                            const dx = touch.clientX - initialX;
                            const dy = touch.clientY - initialY;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            // 如果移动距离超过3px，认为是拖动而不是点击
                            // 降低阈值，让拖动更敏感
                            if (distance > 3) {
                                isDragging = true;
                                lastTouchX = touch.clientX;
                                lastTouchY = touch.clientY;
                                dragStartX = touch.clientX;
                                dragStartY = touch.clientY;
                                dragStartTranslateX = mapTranslateX;
                                dragStartTranslateY = mapTranslateY;
                                touchMoved = true; // 标记为已移动
                            }
                        }
=======
                        // 实时更新地图位置
                        mapTranslateX += adjustedDeltaX;
                        mapTranslateY += adjustedDeltaY;
                            updateMapTransform();
>>>>>>> 3f6217840caedac19671347cee77977866657b6c
                        
                        // 如果正在拖动，更新地图位置
                        if (isDragging && !isPinching) {
                            // 单指拖拽：地图跟随手指移动
                            const deltaX = touch.clientX - lastTouchX;
                            const deltaY = touch.clientY - lastTouchY;
                            
                            // 考虑旋转角度：将屏幕坐标系的移动转换为地图坐标系的移动
                            const rotation = typeof mapRotation !== 'undefined' ? mapRotation : 0;
                            const rad = -rotation * Math.PI / 180; // 反向旋转
                            const adjustedDeltaX = deltaX * Math.cos(rad) - deltaY * Math.sin(rad);
                            const adjustedDeltaY = deltaX * Math.sin(rad) + deltaY * Math.cos(rad);
                            
                            // 实时更新地图位置
                            mapTranslateX += adjustedDeltaX;
                            mapTranslateY += adjustedDeltaY;
                            updateMapTransform();
                            
                            // 更新上一次位置
                            lastTouchX = touch.clientX;
                            lastTouchY = touch.clientY;
                            touchMoved = true;
                        }
                    }
                }, { passive: false });
                
                mapContainer.addEventListener('touchend', (e) => {
                    if (e.touches.length < 2) {
                        isPinching = false;
                    }
                    if (e.touches.length === 0) {
                        // 如果是一次潜在的点击（触摸到节点且没有移动），
                        // 不阻止默认行为，让 click 事件正常触发
                        const wasPotentialClick = currentTouchInfo && 
                                                 currentTouchInfo.isPotentialClick && 
                                                 !touchMoved;
                        
                        isDragging = false;
                        
                        // 清理触摸信息
                        currentTouchInfo = null;
                    }
                    // 如果还有一个手指，准备切换到单指拖拽
                    if (e.touches.length === 1 && !isPinching) {
                        isDragging = true;
                        lastTouchX = e.touches[0].clientX;
                        lastTouchY = e.touches[0].clientY;
                    }
                }, { passive: false }); // 改为 false，以便在需要时可以 preventDefault
                
                // 鼠标拖拽事件处理
                mapContainer.addEventListener('mousedown', (e) => {
                    // 只处理左键
                    if (e.button !== 0) return;
                    // 如果点击的是按钮或输入框，不触发拖拽
                    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.closest('button') || e.target.closest('input')) {
                        return;
                    }
                    e.preventDefault();
                    isDragging = true;
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    dragStartTranslateX = mapTranslateX;
                    dragStartTranslateY = mapTranslateY;
                    mapContainer.style.cursor = 'grabbing';
                });
                
                mapContainer.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                        const deltaX = e.clientX - dragStartX;
                        const deltaY = e.clientY - dragStartY;
                        
                        // 考虑旋转角度：将屏幕坐标系的移动转换为地图坐标系的移动
                        const rotation = typeof mapRotation !== 'undefined' ? mapRotation : 0;
                        const rad = -rotation * Math.PI / 180; // 反向旋转
                        const adjustedDeltaX = deltaX * Math.cos(rad) - deltaY * Math.sin(rad);
                        const adjustedDeltaY = deltaX * Math.sin(rad) + deltaY * Math.cos(rad);
                        
                        mapTranslateX = dragStartTranslateX + adjustedDeltaX;
                        mapTranslateY = dragStartTranslateY + adjustedDeltaY;
                        updateMapTransform();
                    }
                });
                
                mapContainer.addEventListener('mouseup', (e) => {
                    if (isDragging) {
                        isDragging = false;
                        mapContainer.style.cursor = 'grab';
                    }
                });
                
                mapContainer.addEventListener('mouseleave', (e) => {
                    if (isDragging) {
                        isDragging = false;
                        mapContainer.style.cursor = 'grab';
                    }
                });
                
                // 设置初始光标样式
                mapContainer.style.cursor = 'grab';
            }
            
            const zoomInBtn = document.getElementById('zoom-in');
            if (zoomInBtn) {
                zoomInBtn.addEventListener('click', () => {
                    updateMapScale(mapScale + 0.1);
                });
            }
            
            const zoomOutBtn = document.getElementById('zoom-out');
            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('click', () => {
                    updateMapScale(mapScale - 0.1);
                });
            }
            
            const zoomResetBtn = document.getElementById('zoom-reset');
            if (zoomResetBtn) {
                zoomResetBtn.addEventListener('click', () => {
                    updateMapScale(1.0);
                });
            }
            
            // 初始化缩放显示
            if (zoomLevelEl) {
                zoomLevelEl.textContent = '50%';
            }
            
            // 初始化地图缩放为50%
            updateMapScale(0.5);
            
            // 图例水平布局，不需要折叠功能（已移除）

            // 自动刷新监控数据
            setInterval(async () => {
                await fetchMonitorData();
            }, 5000);

            // 自动刷新车辆信息（每2秒，以便实时更新行驶路径）
            setInterval(async () => {
                await fetchMyVehicle();
            }, 2000);

            // 自动刷新路网信息（每30秒，包括节点显示状态）
            setInterval(async () => {
                await fetchNodes(); // 刷新节点数据（包括显示状态）
                await fetchRoads(); // 刷新道路数据
                renderMap(); // 重新渲染地图
            }, 30000);
        }

        // ========== 底部面板拖拽交互 ==========
        function initBottomPanel() {
            const panel = document.getElementById('bottom-panel');
            const handle = document.getElementById('panel-handle');
            const panelContent = document.getElementById('panel-content');
            
            if (!panel || !handle) return;
            
            let startY = 0;
            let startHeight = 0;
            let isDragging = false;
            let dragSource = null; // 'handle' 或 'content'
            
            // 获取面板状态
            function getPanelState() {
                if (panel.classList.contains('collapsed')) return 'collapsed';
                if (panel.classList.contains('expanded')) return 'expanded';
                return 'half';
            }
            
            // 设置面板状态
            function setPanelState(state) {
                panel.classList.remove('collapsed', 'half', 'expanded');
                panel.classList.add(state);
                panel.style.height = ''; // 清除内联高度，使用CSS
            }
            
            // 获取各状态对应的高度
            function getStateHeights() {
                const vh = window.innerHeight;
                const collapsed = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--panel-collapsed')) || 180;
                const topBarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--top-bar-height')) || 50;
                
                return {
                    collapsed: collapsed,
                    half: vh * 0.55,
                    expanded: vh - topBarHeight
                };
            }
            
            // 获取当前面板高度
            function getCurrentHeight() {
                return panel.offsetHeight;
            }
            
            // 触摸/鼠标开始 - 手柄区域
            function handleHandleStart(e) {
                isDragging = true;
                dragSource = 'handle';
                startY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
                startHeight = getCurrentHeight();
                panel.style.transition = 'none';
                
                e.preventDefault();
            }
            
            // 触摸/鼠标开始 - 内容区域
            function handleContentStart(e) {
                const state = getPanelState();
                
                // 展开状态下，如果内容已滚动到顶部，允许向下拖拽收起面板
                if (state === 'expanded' && panelContent.scrollTop <= 0) {
                    startY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
                    startHeight = getCurrentHeight();
                }
            }
            
            // 触摸/鼠标移动
            function handleMove(e) {
                const currentY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
                const deltaY = currentY - startY;
                
                // 如果是从内容区域开始的，检查是否应该开始拖拽面板
                if (!isDragging && dragSource !== 'handle') {
                    const state = getPanelState();
                    
                    // 展开状态下，内容在顶部且向下滑动超过10px时开始拖拽面板
                    if (state === 'expanded' && panelContent.scrollTop <= 0 && deltaY > 10) {
                        isDragging = true;
                        dragSource = 'content';
                        panel.style.transition = 'none';
                        e.preventDefault();
                    }
                }
                
                if (!isDragging) return;
                
                // 计算新高度：向上拖（deltaY < 0）增加高度，向下拖（deltaY > 0）减少高度
                let newHeight = startHeight - deltaY;
                
                // 限制范围
                const heights = getStateHeights();
                const minHeight = heights.collapsed;
                const maxHeight = heights.expanded;
                
                newHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));
                
                panel.style.height = `${newHeight}px`;
                panel.classList.remove('collapsed', 'half', 'expanded');
                
                e.preventDefault();
            }
            
            // 触摸/鼠标结束
            function handleEnd(e) {
                if (!isDragging) {
                    dragSource = null;
                    return;
                }
                isDragging = false;
                
                panel.style.transition = '';
                
                const currentHeight = panel.offsetHeight;
                const heights = getStateHeights();
                
                // 根据当前高度决定最终状态
                const currentY = e.type.includes('mouse') ? e.clientY : (e.changedTouches ? e.changedTouches[0].clientY : startY);
                const deltaY = currentY - startY;
                const velocity = Math.abs(deltaY) > 50; // 快速滑动
                
                if (velocity) {
                    // 快速滑动，根据方向决定
                    if (deltaY > 0) {
                        // 向下滑动（减少高度）
                        if (currentHeight < heights.half) {
                            setPanelState('collapsed');
                        } else {
                            setPanelState('half');
                        }
                    } else {
                        // 向上滑动（增加高度）
                        if (currentHeight > heights.half) {
                            setPanelState('expanded');
                        } else {
                            setPanelState('half');
                        }
                    }
                } else {
                    // 慢速滑动，找最近的状态
                    const distToCollapsed = Math.abs(currentHeight - heights.collapsed);
                    const distToHalf = Math.abs(currentHeight - heights.half);
                    const distToExpanded = Math.abs(currentHeight - heights.expanded);
                    
                    if (distToCollapsed <= distToHalf && distToCollapsed <= distToExpanded) {
                        setPanelState('collapsed');
                    } else if (distToHalf <= distToExpanded) {
                        setPanelState('half');
                    } else {
                        setPanelState('expanded');
                    }
                }
                
                dragSource = null;
            }
            
            // 绑定事件 - 手柄区域
            handle.addEventListener('touchstart', handleHandleStart, { passive: false });
            handle.addEventListener('mousedown', handleHandleStart);
            
            // 绑定事件 - 内容区域（用于展开状态下的下滑收起）
            panelContent.addEventListener('touchstart', handleContentStart, { passive: true });
            panelContent.addEventListener('mousedown', handleContentStart);
            
            // 全局移动和结束事件
            document.addEventListener('touchmove', handleMove, { passive: false });
            document.addEventListener('mousemove', handleMove);
            
            document.addEventListener('touchend', handleEnd);
            document.addEventListener('mouseup', handleEnd);
            
            // 双击切换展开/收起
            handle.addEventListener('dblclick', () => {
                const state = getPanelState();
                if (state === 'expanded') {
                    setPanelState('collapsed');
                } else {
                    setPanelState('expanded');
                }
            });
            
            // 点击手柄时，如果是收起状态，展开到半屏
            handle.addEventListener('click', (e) => {
                // 如果刚刚拖拽过，不响应点击
                if (Math.abs(e.clientY - startY) > 10) return;
                
                const state = getPanelState();
                if (state === 'collapsed') {
                    setPanelState('half');
                }
            });
        }
        
        // ========== 快捷操作按钮 ==========
        function initQuickActions() {
            const buttons = document.querySelectorAll('.quick-action-btn');
            const panel = document.getElementById('bottom-panel');
            
            buttons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const sectionId = btn.dataset.section;
                    const section = document.getElementById(sectionId);
                    
                    if (section) {
                        // 更新按钮状态
                        buttons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        // 展开面板并滚动到对应区块
                        if (panel.classList.contains('collapsed')) {
                            panel.classList.remove('collapsed');
                            panel.classList.add('half');
                        }
                        
                        // 滚动到目标区块
                        setTimeout(() => {
                            section.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }, 100);
                    }
                });
            });
        }
        
        // ========== 更新原有init函数 ==========
        const originalInit = init;
        init = async function() {
            // 初始化底部面板
            initBottomPanel();
            initQuickActions();
            
            // 调用原有初始化
            await originalInit();
            
            // 根据默认模式设置按钮文本
            const initialModeRadio = document.querySelector('.active-mode-radio:checked');
            const calculateBtn = document.getElementById('calculate-route');
            if (initialModeRadio && calculateBtn) {
                if (initialModeRadio.value === 'gps') {
                    calculateBtn.textContent = i18n[currentLang].submit_vehicle || '✅ 提交为实际车辆';
                }
            }
            
            // 更新地图尺寸以适应新布局
            setTimeout(() => {
                if (typeof fitMapToView === 'function') {
                    fitMapToView();
                }
            }, 500);
        };

        // 页面加载时初始化
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>

